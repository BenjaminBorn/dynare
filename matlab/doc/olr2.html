<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of olr2</title>
  <meta name="keywords" content="olr2">
  <meta name="description" content="Copyright (C) 2003 Michel Juillard">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">.</a> &gt; olr2.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>olr2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Copyright (C) 2003 Michel Juillard</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function dr=olr2(dr,olr_inst,bet,obj_var,W) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (C) 2003 Michel Juillard

 computes an optimal policy as the optimal linear regulator</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="union.html" class="code" title="function x = union(a,b)">union</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="olr1.html" class="code" title="function dr = olr1(ys,algo,olr_inst,bet,obj_var,W)">olr1</a>	Copyright (C) 2001 Michel Juillard</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Copyright (C) 2003 Michel Juillard</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% computes an optimal policy as the optimal linear regulator</span>
0004 <span class="comment">%</span>
0005 <a name="_sub0" href="#_subfunctions" class="code">function dr=olr2(dr,olr_inst,bet,obj_var,W)</a>
0006 
0007 <span class="keyword">global</span> M_ options_ oo_
0008 <span class="keyword">global</span> it_ stdexo_
0009 
0010 xlen = M_.maximum_lead + M_.maximum_lag + 1;
0011 klen = M_.maximum_lag + M_.maximum_lead + 1;
0012 iyv = M_.lead_lag_incidence';
0013 iyv = iyv(:);
0014 iyr0 = find(iyv) ;
0015 it_ = M_.maximum_lag + 1 ;
0016 
0017 inst_nbr = size(olr_inst,1);
0018 inst_i = zeros(inst_nbr,1);
0019 <span class="keyword">for</span> i=1:inst_nbr
0020   k = strmatch(olr_inst(i,:),M_.endo_names,<span class="string">'exact'</span>);
0021   <span class="keyword">if</span> isempty(k)
0022     error(sprintf(<span class="string">'OLR_INST %s isn''t a declared variable'</span>));
0023   <span class="keyword">else</span>
0024     inst_i(i) = k;
0025   <span class="keyword">end</span>
0026 <span class="keyword">end</span>
0027 
0028 <span class="keyword">if</span> M_.maximum_lead == 0
0029   error (<span class="string">'OLR : No forward variable: no point in using OLR'</span>) ;
0030 <span class="keyword">end</span>
0031 
0032 <span class="keyword">if</span> find(any(M_.lead_lag_incidence([1:M_.maximum_lag M_.maximum_lag+2:M_.maximum_lead],inst_i),2))
0033   error(<span class="string">'OLR: instruments can only appear at the current period'</span>);
0034 <span class="keyword">end</span>
0035 
0036 non_inst_i = setdiff([1:M_.endo_nbr],inst_i);
0037 iy1_ = M_.lead_lag_incidence(:,non_inst_i);
0038 endo_nbr_1 = M_.endo_nbr - inst_nbr;
0039 
0040 <span class="keyword">if</span> M_.exo_nbr == 0
0041   oo_.exo_steady_state = [] ;
0042 <span class="keyword">end</span>
0043 
0044 <span class="keyword">if</span> ~ M_.lead_lag_incidence(M_.maximum_lag+1,:) &gt; 0
0045   error (<span class="string">'Error in model specification: some variables don''t appear as current'</span>) ;
0046 <span class="keyword">end</span>
0047 
0048 <span class="keyword">if</span> xlen &gt; 1
0049   error ([<span class="string">'SS: stochastic exogenous variables must appear only at the'</span> <span class="keyword">...</span>
0050       <span class="string">' current period. Use additional endogenous variables'</span>]) ;
0051 <span class="keyword">end</span>
0052 
0053 tempex = oo_.exo_simul;
0054 
0055 it_ = M_.maximum_lag + 1;
0056 dr.ys = oo_.steady_state; 
0057 z = repmat(dr.ys,1,klen);
0058 z = z(iyr0) ;
0059 
0060 <span class="comment">%M_.jacobia=real(jacob_a('ff1_',[z; oo_.exo_steady_state])) ;</span>
0061 [junk,M_.jacobia] = feval([M_.fname <span class="string">'_dynamic'</span>],z,oo_.exo_simul);
0062 
0063 oo_.exo_simul = tempex ;
0064 tempex = [];
0065 
0066 nz = size(z,1);
0067 fwrd_var = find(any(M_.lead_lag_incidence(M_.maximum_lag+2:<span class="keyword">end</span>,:),1))';
0068 <span class="keyword">if</span> M_.maximum_lag &gt; 0
0069   pred_var = find(any(M_.lead_lag_incidence(1:M_.maximum_lag,:),1))';
0070   both_var = intersect(pred_var,fwrd_var);
0071   pred_var = setdiff(pred_var,both_var);
0072   fwrd_var = setdiff(fwrd_var,both_var);
0073   stat_var = setdiff([1:M_.endo_nbr]',<a href="union.html" class="code" title="function x = union(a,b)">union</a>(<a href="union.html" class="code" title="function x = union(a,b)">union</a>(pred_var,both_var),fwrd_var));  <span class="comment">% static variables</span>
0074 <span class="keyword">else</span>
0075   pred_var = [];
0076   both_var = [];
0077   stat_var = setdiff([1:M_.endo_nbr]',fwrd_var);
0078 <span class="keyword">end</span>
0079 
0080 stat_var = setdiff(stat_var,inst_i);
0081 <span class="comment">% static variables in objective function</span>
0082 [stat_obj_var] = intersect(obj_var,stat_var);
0083 n_stat_obj_var = length(stat_obj_var);
0084 pred_var = [stat_obj_var; pred_var];
0085 nboth = length(both_var);
0086 npred = length(pred_var);
0087 nfwrd = length(fwrd_var);
0088 nstatic1 = length(stat_var);
0089 nstatic = nstatic1-n_stat_obj_var;
0090 
0091 order_var = [ setdiff(stat_var,obj_var); pred_var; both_var; fwrd_var];
0092 k1 = M_.lead_lag_incidence(find([1:klen] ~= M_.maximum_lag+1),:);
0093 b = M_.jacobia(1:endo_nbr_1,M_.lead_lag_incidence(M_.maximum_lag+1,order_var));
0094 a = b\M_.jacobia(1:endo_nbr_1,nonzeros(k1')); 
0095 <span class="keyword">if</span> M_.exo_nbr
0096   fu = -b\M_.jacobia(1:endo_nbr_1,nz+1:end);
0097 <span class="keyword">end</span>
0098 <span class="comment">% instruments' effects</span>
0099 b = -b\M_.jacobia(1:endo_nbr_1,M_.lead_lag_incidence(M_.maximum_lag+1,inst_i));
0100 <span class="comment">% building kmask for z state vector in t+1</span>
0101 <span class="keyword">if</span> M_.maximum_lag &gt; 0
0102   <span class="keyword">if</span> M_.maximum_lead &gt; 0 
0103     kmask = [flipud(cumsum(M_.lead_lag_incidence(1:M_.maximum_lag,order_var),1))] ;
0104     kmask = [kmask; flipud(cumsum(flipud(M_.lead_lag_incidence(M_.maximum_lag+2:<span class="keyword">end</span>,order_var)),1))] ;
0105   <span class="keyword">end</span>
0106 <span class="keyword">else</span>
0107   kmask = flipud(cumsum(flipud(M_.lead_lag_incidence(M_.maximum_lag+2:klen,order_var)),1));
0108 <span class="keyword">end</span>
0109 <span class="comment">% static variables in objective function</span>
0110 kmask(1,nstatic+1:nstatic1) = 1;
0111 kmask = kmask';
0112 
0113 <span class="comment">% lags aren't ordered as in dr1 !</span>
0114 <span class="comment">% this is necessary to have the zeros on R's diagonal aligned with jump variables</span>
0115 kmask = kmask(:);
0116 i_kmask = find(kmask);          <span class="comment">% index of nonzero entries in kmask</span>
0117 nd = size(i_kmask,1);           <span class="comment">% size of the state vector</span>
0118 kmask(i_kmask) = [1:nd];
0119 
0120 <span class="comment">% auxiliary equations</span>
0121 
0122 <span class="comment">% elements that are both in z(t+1) and z(t)</span>
0123 kad = [];
0124 kae = [];
0125 k1 = find([kmask(1:endo_nbr_1) &amp; kmask(M_.maximum_lag*endo_nbr_1+1:(M_.maximum_lag+1)*endo_nbr_1)] );
0126 <span class="keyword">if</span> ~isempty(k1)
0127   kad = kmask(k1);
0128   kae = kmask(k1+M_.maximum_lag*endo_nbr_1);
0129 <span class="keyword">end</span>
0130 
0131 <span class="keyword">if</span> M_.maximum_lag &gt; 1
0132   k1 = find([kmask(endo_nbr_1+1:M_.maximum_lag*endo_nbr_1) &amp; kmask(1:(M_.maximum_lag-1)*endo_nbr_1)] );
0133   <span class="keyword">if</span> ~isempty(k1)
0134     kad = [kad; kmask(k1+endo_nbr_1)];
0135     kae = [kae; kmask(k1)];
0136   <span class="keyword">end</span>
0137 <span class="keyword">end</span>
0138 <span class="keyword">if</span> M_.maximum_lead &gt; 1
0139   k1 = find([kmask((M_.maximum_lag+1)*endo_nbr_1+1:end) &amp; kmask(M_.maximum_lag*endo_nbr_1+1:end-endo_nbr_1)] );
0140   <span class="keyword">if</span> ~isempty(k1)
0141     kad = [kad; kmask(M_.maximum_lag*endo_nbr_1+k1)];
0142     kae = [kae; kmask((M_.maximum_lag+1)*endo_nbr_1+k1)];
0143   <span class="keyword">end</span>
0144 <span class="keyword">end</span>
0145 
0146 <span class="comment">% composition of state vector</span>
0147 <span class="comment">% col 1: variable;           col 2: lead/lag in z(t+1);</span>
0148 <span class="comment">% col 3: A cols for t+1 (D); col 4: A cols for t (E)</span>
0149 kstate = [ repmat([1:endo_nbr_1]',klen-1,1) <span class="keyword">...</span>
0150        [kron([M_.maximum_lag+1:-1:2]',ones(endo_nbr_1,1)); <span class="keyword">...</span>
0151         kron([M_.maximum_lag+2:klen]',ones(endo_nbr_1,1))] <span class="keyword">...</span>
0152        zeros((klen-1)*endo_nbr_1,2)];
0153 kiy = [flipud(M_.lead_lag_incidence(1:M_.maximum_lag+1,order_var)); M_.lead_lag_incidence(M_.maximum_lag+2:<span class="keyword">end</span>,order_var)]';
0154 kiy = kiy(:);
0155 i1 = find(kiy((M_.maximum_lag+1)*endo_nbr_1+1:end));
0156 kstate(i1+M_.maximum_lag*endo_nbr_1,3) = kiy(i1+(M_.maximum_lag+1)*endo_nbr_1)-M_.endo_nbr;  
0157 kstate(1:M_.maximum_lag*endo_nbr_1,4) = kiy(endo_nbr_1+1:(M_.maximum_lag+1)*endo_nbr_1);  
0158 <span class="comment">% put in E only the current variables that are not already in D</span>
0159 kstate = kstate(i_kmask,:);
0160 
0161 sdyn = M_.endo_nbr-nstatic-inst_nbr;
0162 
0163 <span class="comment">% buildind D and E</span>
0164 d = zeros(nd,nd) ;
0165 e = d ;
0166 
0167 <span class="comment">% dynamical system</span>
0168 k = find(kstate(:,2) &gt;= M_.maximum_lag+2 &amp; kstate(:,3));
0169 d(1:sdyn,k) = a(nstatic+1:<span class="keyword">end</span>,kstate(k,3)) ;
0170 k1 = find(kstate(:,2) == M_.maximum_lag+2);
0171 a1 = eye(sdyn);
0172 e(1:sdyn,k1) =  -a1(:,kstate(k1,1)-nstatic);
0173 k = find(kstate(:,2) &lt;= M_.maximum_lag+1 &amp; kstate(:,4));
0174 e(1:sdyn,k) = -a(nstatic+1:<span class="keyword">end</span>,kstate(k,4)) ;
0175 k2 = find(kstate(:,2) == M_.maximum_lag+1);
0176 k2 = k2(~ismember(kstate(k2,1),kstate(k1,1)));
0177 d(1:sdyn,k2) = a1(:,kstate(k2,1)-nstatic);
0178   
0179 <span class="keyword">if</span> ~isempty(kad)
0180   <span class="keyword">for</span> j = 1:size(kad,1)
0181     d(sdyn+j,kad(j)) = 1 ;
0182     e(sdyn+j,kae(j)) = 1 ;
0183   <span class="keyword">end</span>
0184 <span class="keyword">end</span>
0185 [Q,R] = qr(d);
0186 C = Q'*[e [[b(nstatic+1:<span class="keyword">end</span>,:) fu(nstatic+1:<span class="keyword">end</span>,:)];<span class="keyword">...</span>
0187        zeros(nd-sdyn,inst_nbr+M_.exo_nbr)]];
0188 
0189 nyf = sum(kstate(:,2) &gt; M_.maximum_lag+1);
0190 
0191 
0192 np = nd - nyf;
0193 
0194 
0195 dd = zeros(2*nd+inst_nbr,2*nd+inst_nbr);
0196 ee = dd;
0197 
0198 dd(1:nd,1:np) = R(:,1:np);
0199 ee(1:nd,1:np) = C(:,1:np);
0200 dd(1:nd,nd+1:nd+nyf) = R(:,np+1:end);
0201 ee(1:nd,nd+1:nd+nyf+inst_nbr) = C(:,np+1:nd+inst_nbr);
0202 
0203 
0204 <span class="comment">% derivatives with respect to x</span>
0205 <span class="comment">% building QQ and UU</span>
0206 m = 1;
0207 v0 = kstate(find(kstate(:,2)==M_.maximum_lag+2),1);
0208 <span class="keyword">for</span> i=1:nd;
0209   <span class="keyword">if</span> (kstate(i,2) == M_.maximum_lag+1 &amp; isempty(find(kstate(i,1)==v0)))
0210     k = find(order_var(kstate(i,1))==obj_var);
0211     <span class="keyword">if</span> ~isempty(k)
0212       iq(m) = i;
0213       m = m+1;
0214     <span class="keyword">end</span>
0215   <span class="keyword">elseif</span> kstate(i,2) == M_.maximum_lag+2
0216     k = find(order_var(kstate(i,1))==obj_var);
0217     <span class="keyword">if</span> ~isempty(k)
0218       iq(m) = i;
0219       m = m+1;
0220     <span class="keyword">end</span>
0221   <span class="keyword">end</span>
0222 <span class="keyword">end</span>
0223 QQ1 = zeros(nd,nd);
0224 QQ1(iq,iq) = W(obj_var,obj_var);
0225 UU1 = zeros(nd,inst_nbr);
0226 UU1(iq,:) = W(obj_var,inst_i);
0227 RR = W(inst_i,inst_i);
0228 offset = nd;
0229 ee(offset+1:2*offset,1:np) = bet*QQ1(1:np,:)';
0230 dd(offset+1:2*offset,np+1:nd) = bet*C(np+1:nd,1:nd)';
0231 ee(offset+1:2*offset,nd+1:nd+nyf) = bet*QQ1(np+1:<span class="keyword">end</span>,:)';
0232 dd(offset+1:2*offset,nd+nyf+inst_nbr+1:end)=bet*C(1:np,1:nd)';
0233 ee(offset+1:2*offset,np+1:nd) = R(np+1:<span class="keyword">end</span>,:)';
0234 ee(offset+1:2*offset,nd+nyf+1:nd+nyf+inst_nbr) = -bet*UU1;
0235 ee(offset+1:2*offset,nd+nyf+inst_nbr+1:end) = R(1:np,:)';
0236 
0237 <span class="comment">%derivatives with respect to u</span>
0238 offset = 2*nd;
0239 dd(offset+1:<span class="keyword">end</span>,np+1:nd) = -C(np+1:<span class="keyword">end</span>,nd+1:nd+inst_nbr)';
0240 dd(offset+1:<span class="keyword">end</span>,nd+nyf+inst_nbr+1:end) = -C(1:np,nd+1:nd+inst_nbr)';
0241 ee(offset+1:<span class="keyword">end</span>,1:np) = UU1(1:np,:)';
0242 ee(offset+1:<span class="keyword">end</span>,nd+1:nd+nyf) = UU1(np+1:<span class="keyword">end</span>,:)';
0243 ee(offset+1:<span class="keyword">end</span>,nd+nyf+1:nd+nyf+inst_nbr) = RR;
0244 
0245 [ss,tt,w,sdim,oo_.eigenvalues,info] = mjdgges(ee,dd);
0246 
0247 nba = sum(abs(oo_.eigenvalues) &gt; 1+1e-5);
0248 nyf1 = nd+inst_nbr;
0249 nd = 2*nd+inst_nbr;
0250 
0251 <span class="keyword">if</span> nba ~= nyf1;
0252   warning(<span class="string">'OLR: Blanchard-Kahn conditions are not satisfied.'</span>);
0253 <span class="keyword">end</span>
0254 
0255 np1 = nd - nyf1;
0256 n2 = np1 + 1;
0257 n3 = np1;
0258 n4 = n3 + 1;
0259 
0260 <span class="comment">% derivatives with respect to dynamic state variables</span>
0261 <span class="comment">% forward variables</span>
0262 gx = -w(n4:nd,n2:nd)'\w(1:n3,n2:nd)';
0263 <span class="comment">% predetermined variables</span>
0264 hx = w(n4:nd,1:np1)'*gx+w(1:n3,1:np1)';
0265 hx = (tt(1:np1,1:np1)*hx)\(ss(1:np1,1:np1)*hx);
0266 
0267 <span class="comment">% including Lagrange multipliers in M_.endo_names, order_var and kstate</span>
0268 <span class="keyword">for</span> i=1:M_.maximum_lead
0269   k = find(kstate(:,2)==M_.maximum_lag+1+i);
0270   temp = strcat(<span class="string">'mult_'</span>,M_.endo_names(order_var(kstate(k,1)),:));
0271   temp = strcat(temp,[<span class="string">'_'</span> int2str(i)]);
0272   M_.endo_names = strvcat(M_.endo_names,temp);
0273 <span class="keyword">end</span>
0274 
0275 <span class="keyword">if</span> nyf &gt; nboth    
0276   order_var = [order_var(1:nstatic+npred+nboth);[M_.endo_nbr+1:M_.endo_nbr+nyf]'; <span class="keyword">...</span>
0277           order_var(nstatic+npred+nboth+1:end); inst_i];
0278 <span class="keyword">else</span>
0279   order_var = [order_var(1:nstatic+npred+nboth);[M_.endo_nbr+1:M_.endo_nbr+nyf]'; <span class="keyword">...</span>
0280           inst_i];
0281 <span class="keyword">end</span>
0282 kstate = [kstate(1:np,:);zeros(nyf,4);kstate(np+1:<span class="keyword">end</span>,:);zeros(inst_nbr+np,4)];
0283 k = find(kstate(:,2) &lt;= M_.maximum_lag+1);
0284 kstate(np+1:np+nyf,1:2) = [[nstatic+npred+nboth+1:nstatic+npred+nboth+nyf]' <span class="keyword">...</span>
0285             (M_.maximum_lag+1)*ones(nyf,1)];
0286 kstate(np+2*nyf+1:np+2*nyf+inst_nbr,1:2) = [[endo_nbr_1+1:endo_nbr_1+inst_nbr]' <span class="keyword">...</span>
0287             (M_.maximum_lag+2)*ones(inst_nbr,1)];
0288 kstate(np+2*nyf+inst_nbr+1:<span class="keyword">end</span>,1:2) = [[M_.endo_nbr+1:M_.endo_nbr+np]' (M_.maximum_lag+2)*ones(np,1)];
0289 
0290 k1 = find(kstate(:,2) == M_.maximum_lag+1);
0291 k2 = find(kstate(:,2) == M_.maximum_lag+2)-np-nyf;
0292 dr.ghx = [hx(k1,:); gx(k2(nboth+1:end),:)];
0293 
0294 <span class="comment">%lead variables actually present in the model</span>
0295 <span class="comment">% derivatives with respect to exogenous variables</span>
0296 <span class="keyword">if</span> M_.exo_nbr
0297   n1 = find(kstate(:,2) &gt; M_.maximum_lag+1);
0298   ghu = [dd(:,n1(1):end)*gx+dd(:,1:n1(1)-1) -ee(:,np+nyf+1:end)]\[C(:,end-M_.exo_nbr+1:end); zeros(size(dd,1)-size(C,1),M_.exo_nbr)];
0299   dr.ghu = [ghu(k1,:);ghu(k2(nboth+1:end)+np+nyf,:)];
0300 <span class="keyword">end</span>
0301 
0302 <span class="comment">% static variables</span>
0303 <span class="keyword">if</span> nstatic &gt; 0
0304   j3 = nonzeros(kstate(:,3));
0305   j4  = find(kstate(:,3))-np-nyf;
0306   temp = -a(1:nstatic,j3)*gx(j4,:)*hx;
0307   temp = temp + b(1:nstatic,:)*gx(nyf+1:nyf+inst_nbr,:);
0308   j5 = find(kstate(:,4));
0309   temp(:,j5) = temp(:,j5)-a(1:nstatic,nonzeros(kstate(:,4)));
0310   dr.ghx = [temp; dr.ghx];
0311   temp = -a(1:nstatic,j3)*gx(j4,:)*ghu(1:np+nyf,:);
0312   temp = temp + b(1:nstatic,:)*ghu(np+2*nyf+1:np+2*nyf+inst_nbr,:);
0313   temp = temp + fu(1:nstatic,:);
0314   dr.ghu = [temp; dr.ghu]; 
0315   temp = [];
0316 <span class="keyword">end</span>
0317 
0318 dr.ghx = dr.ghx(1:M_.endo_nbr+nyf,:);
0319 dr.ghu = dr.ghu(1:M_.endo_nbr+nyf,:);
0320 
0321 dr.ys = [dr.ys; zeros(nyf,1)];
0322 dr.nstatic1 = nstatic1;
0323 dr.nstatic = nstatic;
0324 dr.npred = npred+nyf+nboth;
0325 dr.kstate = kstate;
0326 dr.order_var = order_var;
0327 M_.endo_nbr = M_.endo_nbr+nyf;
0328 
0329 <span class="comment">% 05/29/03 MJ replaced diffext by jacobia (much faster)</span>
0330 <span class="comment">%             corrected kmask for static variables in objective function</span>
0331 
0332 
0333 
0334</pre></div>
<hr><address>Generated on Fri 16-Jun-2006 09:09:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>