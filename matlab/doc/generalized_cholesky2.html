<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of generalized_cholesky2</title>
  <meta name="keywords" content="generalized_cholesky2">
  <meta name="description" content="/*">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">.</a> &gt; generalized_cholesky2.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>generalized_cholesky2
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>/*</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function AA = generalized_cholesky2(A) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> /*
 **  By Jeff Gill, April 2002.
 **
 **  This procedure produces:
 **
 **  y = chol(A+E), where E is a diagonal matrix with each element as small
 **  as possible, and A and E are the same size.  E diagonal values are 
 **  constrained by iteravely updated Gerschgorin bounds.  
 **
 **  REFERENCES:
 **
 **  Jeff Gill and Gary King. 1998. &quot;`Hessian not Invertable.' Help!&quot;
 **  manuscript in progress, Harvard University.
 **
 **  Robert B. Schnabel and Elizabeth Eskow. 1990. &quot;A New Modified Cholesky
 **  Factorization,&quot; SIAM Journal of Scientific Statistical Computating,
 **  11, 6: 1136-58.
 **
 **
 **
 **  Stphane Adjemian (2003): translation from Gauss to Matlab.  
 */</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% /*</span>
0002 <span class="comment">% **  By Jeff Gill, April 2002.</span>
0003 <span class="comment">% **</span>
0004 <span class="comment">% **  This procedure produces:</span>
0005 <span class="comment">% **</span>
0006 <span class="comment">% **  y = chol(A+E), where E is a diagonal matrix with each element as small</span>
0007 <span class="comment">% **  as possible, and A and E are the same size.  E diagonal values are</span>
0008 <span class="comment">% **  constrained by iteravely updated Gerschgorin bounds.</span>
0009 <span class="comment">% **</span>
0010 <span class="comment">% **  REFERENCES:</span>
0011 <span class="comment">% **</span>
0012 <span class="comment">% **  Jeff Gill and Gary King. 1998. &quot;`Hessian not Invertable.' Help!&quot;</span>
0013 <span class="comment">% **  manuscript in progress, Harvard University.</span>
0014 <span class="comment">% **</span>
0015 <span class="comment">% **  Robert B. Schnabel and Elizabeth Eskow. 1990. &quot;A New Modified Cholesky</span>
0016 <span class="comment">% **  Factorization,&quot; SIAM Journal of Scientific Statistical Computating,</span>
0017 <span class="comment">% **  11, 6: 1136-58.</span>
0018 <span class="comment">% **</span>
0019 <span class="comment">% **</span>
0020 <span class="comment">% **</span>
0021 <span class="comment">% **  Stphane Adjemian (2003): translation from Gauss to Matlab.</span>
0022 <span class="comment">% */</span>
0023 <a name="_sub0" href="#_subfunctions" class="code">function AA = generalized_cholesky2(A)</a>
0024 
0025 n = size(A,1);
0026 L = zeros(n,n);
0027 deltaprev = 0;
0028 gamm = max(abs(diag(A))); 
0029 tau = eps^(1/3);
0030 
0031 <span class="keyword">if</span>  min(eig(A)) &gt; 0;
0032     tau = -1000000;
0033 <span class="keyword">end</span>;
0034 
0035 norm_A = max(sum(abs(A))');
0036 gamm = max(abs(diag(A))); 
0037 delta = max([eps*norm_A;eps]);
0038 Pprod = eye(n);
0039   
0040 <span class="keyword">if</span> n &gt; 2; 
0041     <span class="keyword">for</span> k = 1,n-2;
0042          <span class="keyword">if</span> min((diag(A(k+1:n,k+1:n))' - A(k,k+1:n).^2/A(k,k))') &lt; tau*gamm <span class="keyword">...</span>
0043                 &amp; min(eig(A((k+1):n,(k+1):n))) &lt; 0;
0044             [tmp,dmax] = max(diag(A(k:n,k:n)));
0045             <span class="keyword">if</span> A(k+dmax-1,k+dmax-1) &gt; A(k,k);
0046                 P = eye(n);
0047                 Ptemp = P(k,:); 
0048                 P(k,:) = P(k+dmax-1,:); 
0049                 P(k+dmax-1,:) = Ptemp;
0050                 A = P*A*P;
0051                 L = P*L*P;
0052                 Pprod = P*Pprod;
0053              <span class="keyword">end</span>;
0054              g = zeros(n-(k-1),1);
0055              <span class="keyword">for</span> i=k:n;  
0056                 <span class="keyword">if</span> i == 1;
0057                     sum1 = 0;
0058                 <span class="keyword">else</span>;
0059                     sum1 = sum(abs(A(i,k:(i-1)))');
0060                 <span class="keyword">end</span>;
0061                 <span class="keyword">if</span> i == n;
0062                     sum2 = 0;
0063                 <span class="keyword">else</span>;
0064                     sum2 = sum(abs(A((i+1):n,i)));
0065                 <span class="keyword">end</span>; 
0066                 g(i-k+1) = A(i,i) - sum1 - sum2;
0067              <span class="keyword">end</span>; 
0068              [tmp,gmax] = max(g);
0069              <span class="keyword">if</span> gmax ~= k;
0070                 P = eye(n);
0071                 Ptemp  = P(k,:); 
0072                 P(k,:) = P(k+dmax-1,:); 
0073                 P(k+dmax-1,:) = Ptemp;
0074                 A = P*A*P;
0075                 L = P*L*P;
0076                 Pprod = P*Pprod;
0077              <span class="keyword">end</span>; 
0078              normj = sum(abs(A(k+1:n,k)));
0079              delta = max([0;deltaprev;-A(k,k)+normj;-A(k,k)+tau*gamm]);
0080              <span class="keyword">if</span> delta &gt; 0;
0081                A(k,k) = A(k,k) + delta;
0082                deltaprev = delta;
0083              <span class="keyword">end</span>;
0084          <span class="keyword">end</span>; 
0085          A(k,k) = sqrt(A(k,k));
0086          L(k,k) = A(k,k); 
0087          <span class="keyword">for</span> i=k+1:n; 
0088             <span class="keyword">if</span> L(k,k) &gt; eps; 
0089                 A(i,k) = A(i,k)/L(k,k); 
0090             <span class="keyword">end</span>;
0091             L(i,k) = A(i,k);
0092             A(i,k+1:i) = A(i,k+1:i) - L(i,k)*L(k+1:i,k)';
0093             <span class="keyword">if</span> A(i,i) &lt; 0; 
0094                 A(i,i) = 0; 
0095             <span class="keyword">end</span>;
0096          <span class="keyword">end</span>;
0097     <span class="keyword">end</span>;
0098 <span class="keyword">end</span>;
0099 A(n-1,n) = A(n,n-1);
0100 eigvals  = eig(A(n-1:n,n-1:n));
0101 dlist    = [ 0 ; deltaprev ;<span class="keyword">...</span>
0102         -min(eigvals)+tau*max((inv(1-tau)*max(eigvals)-min(eigvals))|gamm) ]; 
0103 <span class="keyword">if</span> dlist(1) &gt; dlist(2); 
0104     delta = dlist(1);   
0105 <span class="keyword">else</span>;
0106     delta = dlist(2);
0107 <span class="keyword">end</span>;
0108 <span class="keyword">if</span> delta &lt; dlist(3);
0109     delta = dlist(3);
0110 <span class="keyword">end</span>;
0111 <span class="keyword">if</span> delta &gt; 0;
0112     A(n-1,n-1) = A(n-1,n-1) + delta;
0113     A(n,n) = A(n,n) + delta;
0114     deltaprev = delta;
0115 <span class="keyword">end</span>;
0116 A(n-1,n-1) = sqrt(A(n-1,n-1));
0117 L(n-1,n-1) = A(n-1,n-1);
0118 A(n,n-1) = A(n,n-1)/L(n-1,n-1);
0119 L(n,n-1) = A(n,n-1);
0120 A(n,n) = sqrt(A(n,n) - L(n,(n-1))^2);
0121 L(n,n) = A(n,n);
0122 AA = Pprod'*L'*Pprod';</pre></div>
<hr><address>Generated on Fri 16-Jun-2006 09:09:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>