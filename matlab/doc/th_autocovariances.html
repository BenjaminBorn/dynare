<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of th_autocovariances</title>
  <meta name="keywords" content="th_autocovariances">
  <meta name="description" content="Copyright (C) 2001 Michel Juillard">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">.</a> &gt; th_autocovariances.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for .&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>th_autocovariances
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Copyright (C) 2001 Michel Juillard</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [Gamma_y,ivar]=th_autocovariances(dr,ivar) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Copyright (C) 2001 Michel Juillard

 computes the theoretical auto-covariances, Gamma_y, for an AR(p) process 
 with coefficients dr.ghx and dr.ghu and shock variances Sigma_e_
 for a subset of variables ivar (indices in lgy_)
 Theoretical HP filtering is available as an option</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="kalman_transition_matrix.html" class="code" title="function [A,B] = kalman_transition_matrix(dr)">kalman_transition_matrix</a>	makes transition matrices out of ghx and ghu for Kalman filter</li><li><a href="lyapunov_symm.html" class="code" title="function [x,ns_var]=lyapunov_symm(a,b)">lyapunov_symm</a>	solves x-a*x*a'=b for b (and then x) symmetrical</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="disp_th_moments.html" class="code" title="function disp_th_moments(dr,var_list)">disp_th_moments</a>	Copyright (C) 2001 Michel Juillard</li></ul>
<!-- crossreference -->


<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="comment">% Copyright (C) 2001 Michel Juillard</span>
0002 <span class="comment">%</span>
0003 <span class="comment">% computes the theoretical auto-covariances, Gamma_y, for an AR(p) process</span>
0004 <span class="comment">% with coefficients dr.ghx and dr.ghu and shock variances Sigma_e_</span>
0005 <span class="comment">% for a subset of variables ivar (indices in lgy_)</span>
0006 <span class="comment">% Theoretical HP filtering is available as an option</span>
0007 
0008 <a name="_sub0" href="#_subfunctions" class="code">function [Gamma_y,ivar]=th_autocovariances(dr,ivar)</a>
0009   <span class="keyword">global</span> M_ options_
0010 
0011   exo_names_orig_ord  = M_.exo_names_orig_ord;
0012   <span class="keyword">if</span> sscanf(version(<span class="string">'-release'</span>),<span class="string">'%d'</span>) &lt; 13
0013     warning off
0014   <span class="keyword">else</span>
0015     eval(<span class="string">'warning off MATLAB:dividebyzero'</span>)
0016   <span class="keyword">end</span>
0017   nar = options_.ar;
0018   Gamma_y = cell(nar+1,1);
0019   <span class="keyword">if</span> isempty(ivar)
0020     ivar = [1:M_.endo_nbr]';
0021   <span class="keyword">end</span>
0022   nvar = size(ivar,1);
0023   
0024   ghx = dr.ghx;
0025   ghu = dr.ghu;
0026   npred = dr.npred;
0027   nstatic = dr.nstatic;
0028   kstate = dr.kstate;
0029   order = dr.order_var;
0030   iv(order) = [1:length(order)];
0031   nx = size(ghx,2);
0032   
0033   ikx = [nstatic+1:nstatic+npred];
0034   
0035   A = zeros(nx,nx);
0036   k0 = kstate(find(kstate(:,2) &lt;= M_.maximum_lag+1),:);
0037   i0 = find(k0(:,2) == M_.maximum_lag+1);
0038   i00 = i0;
0039   n0 = length(i0);
0040   A(i0,:) = ghx(ikx,:);
0041   AS = ghx(:,i0);
0042   ghu1 = zeros(nx,M_.exo_nbr);
0043   ghu1(i0,:) = ghu(ikx,:);
0044   <span class="keyword">for</span> i=M_.maximum_lag:-1:2
0045     i1 = find(k0(:,2) == i);
0046     n1 = size(i1,1);
0047     j1 = zeros(n1,1);
0048     j2 = j1;
0049     <span class="keyword">for</span> k1 = 1:n1
0050       j1(k1) = find(k0(i00,1)==k0(i1(k1),1));
0051       j2(k1) = find(k0(i0,1)==k0(i1(k1),1));
0052     <span class="keyword">end</span>
0053     AS(:,j1) = AS(:,j1)+ghx(:,i1);
0054     i0 = i1;
0055   <span class="keyword">end</span>
0056   b = ghu1*M_.Sigma_e*ghu1';
0057 
0058 
0059   [A,B] = <a href="kalman_transition_matrix.html" class="code" title="function [A,B] = kalman_transition_matrix(dr)">kalman_transition_matrix</a>(dr);
0060   <span class="comment">% index of predetermined variables in A</span>
0061   i_pred = [nstatic+(1:npred) M_.endo_nbr+1:length(A)];
0062   A = A(i_pred,i_pred);
0063 
0064   <span class="keyword">if</span> options_.order == 2
0065     [vx,ns_var] =  <a href="lyapunov_symm.html" class="code" title="function [x,ns_var]=lyapunov_symm(a,b)">lyapunov_symm</a>(A,b);
0066     i_ivar = find(~ismember(ivar,dr.order_var(ns_var+nstatic)));
0067     ivar = ivar(i_ivar);
0068     iky = iv(ivar);  
0069     aa = ghx(iky,:);
0070     bb = ghu(iky,:);
0071     Ex = (dr.ghs2(ikx)+dr.ghxx(ikx,:)*vx(:)+dr.ghuu(ikx,:)*M_.Sigma_e(:))/2;
0072     Ex = (eye(n0)-AS(ikx,:))\Ex;
0073     Gamma_y{nar+3} = AS(iky,:)*Ex+(dr.ghs2(iky)+dr.ghxx(iky,:)*vx(:)+dr.ghuu(iky,:)*M_.Sigma_e(:))/2;
0074   <span class="keyword">end</span>
0075   <span class="keyword">if</span> options_.hp_filter == 0
0076     <span class="keyword">if</span> options_.order &lt; 2
0077       [vx, ns_var] =  <a href="lyapunov_symm.html" class="code" title="function [x,ns_var]=lyapunov_symm(a,b)">lyapunov_symm</a>(A,b);
0078       i_ivar = find(~ismember(ivar,dr.order_var(ns_var+nstatic)));
0079       ivar = ivar(i_ivar);
0080       iky = iv(ivar);  
0081       aa = ghx(iky,:);
0082       bb = ghu(iky,:);
0083     <span class="keyword">end</span>
0084     Gamma_y{1} = aa*vx*aa'+ bb*M_.Sigma_e*bb';
0085     k = find(abs(Gamma_y{1}) &lt; 1e-12);
0086     Gamma_y{1}(k) = 0;
0087     
0088     <span class="comment">% autocorrelations</span>
0089     <span class="keyword">if</span> nar &gt; 0
0090       vxy = (A*vx*aa'+ghu1*M_.Sigma_e*bb');
0091 
0092       sy = sqrt(diag(Gamma_y{1}));
0093       sy = sy *sy';
0094       Gamma_y{2} = aa*vxy./sy;
0095       
0096       <span class="keyword">for</span> i=2:nar
0097     vxy = A*vxy;
0098     Gamma_y{i+1} = aa*vxy./sy;
0099       <span class="keyword">end</span>
0100     <span class="keyword">end</span>
0101     
0102     <span class="comment">% variance decomposition</span>
0103     <span class="keyword">if</span> M_.exo_nbr &gt; 1
0104       Gamma_y{nar+2} = zeros(length(ivar),M_.exo_nbr);
0105       SS(exo_names_orig_ord,exo_names_orig_ord)=M_.Sigma_e+1e-14*eye(M_.exo_nbr);
0106       cs = chol(SS)';
0107       b1(:,exo_names_orig_ord) = ghu1;
0108       b1 = b1*cs;
0109       b2(:,exo_names_orig_ord) = ghu(iky,:);
0110       b2 = b2*cs;
0111       vx  = <a href="lyapunov_symm.html" class="code" title="function [x,ns_var]=lyapunov_symm(a,b)">lyapunov_symm</a>(A,b1*b1');
0112       vv = diag(aa*vx*aa'+b2*b2');
0113       <span class="keyword">for</span> i=1:M_.exo_nbr
0114     vx1 = <a href="lyapunov_symm.html" class="code" title="function [x,ns_var]=lyapunov_symm(a,b)">lyapunov_symm</a>(A,b1(:,i)*b1(:,i)');
0115     Gamma_y{nar+2}(:,i) = abs(diag(aa*vx1*aa'+b2(:,i)*b2(:,i)'))./vv;
0116       <span class="keyword">end</span>
0117     <span class="keyword">end</span>
0118   <span class="keyword">else</span>
0119     <span class="keyword">if</span> options_.order &lt; 2
0120       iky = iv(ivar);  
0121       aa = ghx(iky,:);
0122       bb = ghu(iky,:);
0123     <span class="keyword">end</span>
0124     lambda = options_.hp_filter;
0125     ngrid = options_.hp_ngrid;
0126     freqs = 0 : ((2*pi)/ngrid) : (2*pi*(1 - .5/ngrid)); 
0127     tpos  = exp( sqrt(-1)*freqs);
0128     tneg  =  exp(-sqrt(-1)*freqs);
0129     hp1 = 4*lambda*(1 - cos(freqs)).^2 ./ (1 + 4*lambda*(1 - cos(freqs)).^2);
0130     
0131     mathp_col = [];
0132     IA = eye(size(A,1));
0133     IE = eye(M_.exo_nbr);
0134     <span class="keyword">for</span> ig = 1:ngrid
0135       f_omega  =(1/(2*pi))*( [inv(IA-A*tneg(ig))*ghu1;IE]<span class="keyword">...</span>
0136                  *M_.Sigma_e*[ghu1'*inv(IA-A'*tpos(ig)) <span class="keyword">...</span>
0137             IE]); <span class="comment">% state variables</span>
0138       g_omega = [aa*tneg(ig) bb]*f_omega*[aa'*tpos(ig); bb']; <span class="comment">% selected variables</span>
0139       f_hp = hp1(ig)^2*g_omega; <span class="comment">% spectral density of selected filtered series</span>
0140       mathp_col = [mathp_col ; (f_hp(:))'];    <span class="comment">% store as matrix row</span>
0141                                                <span class="comment">% for ifft</span>
0142     <span class="keyword">end</span>;
0143 
0144     <span class="comment">% covariance of filtered series</span>
0145     imathp_col = real(ifft(mathp_col))*(2*pi);
0146 
0147     Gamma_y{1} = reshape(imathp_col(1,:),nvar,nvar);
0148     
0149     <span class="comment">% autocorrelations</span>
0150     <span class="keyword">if</span> nar &gt; 0
0151       sy = sqrt(diag(Gamma_y{1}));
0152       sy = sy *sy';
0153       <span class="keyword">for</span> i=1:nar
0154     Gamma_y{i+1} = reshape(imathp_col(i+1,:),nvar,nvar)./sy;
0155       <span class="keyword">end</span>
0156     <span class="keyword">end</span>
0157     
0158     <span class="comment">%variance decomposition</span>
0159     <span class="keyword">if</span> M_.exo_nbr &gt; 1 
0160       Gamma_y{nar+2} = zeros(nvar,M_.exo_nbr);
0161       SS(exo_names_orig_ord,exo_names_orig_ord)=M_.Sigma_e+1e-14*eye(M_.exo_nbr);
0162       cs = chol(SS)';
0163       SS = cs*cs';
0164       b1(:,exo_names_orig_ord) = ghu1;
0165       b2(:,exo_names_orig_ord) = ghu(iky,:);
0166       mathp_col = [];
0167       IA = eye(size(A,1));
0168       IE = eye(M_.exo_nbr);
0169       <span class="keyword">for</span> ig = 1:ngrid
0170     f_omega  =(1/(2*pi))*( [inv(IA-A*tneg(ig))*b1;IE]<span class="keyword">...</span>
0171                    *SS*[b1'*inv(IA-A'*tpos(ig)) <span class="keyword">...</span>
0172             IE]); <span class="comment">% state variables</span>
0173     g_omega = [aa*tneg(ig) b2]*f_omega*[aa'*tpos(ig); b2']; <span class="comment">% selected variables</span>
0174     f_hp = hp1(ig)^2*g_omega; <span class="comment">% spectral density of selected filtered series</span>
0175     mathp_col = [mathp_col ; (f_hp(:))'];    <span class="comment">% store as matrix row</span>
0176                          <span class="comment">% for ifft</span>
0177       <span class="keyword">end</span>;
0178 
0179       imathp_col = real(ifft(mathp_col))*(2*pi);
0180       vv = diag(reshape(imathp_col(1,:),nvar,nvar));
0181       <span class="keyword">for</span> i=1:M_.exo_nbr
0182     mathp_col = [];
0183     SSi = cs(:,i)*cs(:,i)';
0184     <span class="keyword">for</span> ig = 1:ngrid
0185       f_omega  =(1/(2*pi))*( [inv(IA-A*tneg(ig))*b1;IE]<span class="keyword">...</span>
0186                  *SSi*[b1'*inv(IA-A'*tpos(ig)) <span class="keyword">...</span>
0187             IE]); <span class="comment">% state variables</span>
0188       g_omega = [aa*tneg(ig) b2]*f_omega*[aa'*tpos(ig); b2']; <span class="comment">% selected variables</span>
0189       f_hp = hp1(ig)^2*g_omega; <span class="comment">% spectral density of selected filtered series</span>
0190       mathp_col = [mathp_col ; (f_hp(:))'];    <span class="comment">% store as matrix row</span>
0191                            <span class="comment">% for ifft</span>
0192     <span class="keyword">end</span>;
0193 
0194     imathp_col = real(ifft(mathp_col))*(2*pi);
0195     Gamma_y{nar+2}(:,i) = abs(diag(reshape(imathp_col(1,:),nvar,nvar)))./vv;
0196       <span class="keyword">end</span>
0197     <span class="keyword">end</span>
0198   <span class="keyword">end</span>
0199   <span class="keyword">if</span> sscanf(version(<span class="string">'-release'</span>),<span class="string">'%d'</span>) &lt; 13
0200     warning on
0201   <span class="keyword">else</span>
0202     eval(<span class="string">'warning on MATLAB:dividebyzero'</span>)
0203   <span class="keyword">end</span>
0204</pre></div>
<hr><address>Generated on Fri 16-Jun-2006 09:09:06 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>