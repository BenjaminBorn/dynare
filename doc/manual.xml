<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book>
  <bookinfo>
    <title>Dynare Manual</title>
    <subtitle>Version 4.0.2 (draft)</subtitle>
    <author>
      <firstname>Michel</firstname><surname>Juillard</surname>
      <affiliation><orgname>CEPREMAP and University Paris 8</orgname></affiliation>
      <email>michel.juillard@ens.fr</email>
      <address><street>48 bd Jourdan</street><postcode>75014</postcode><city>Paris</city><country>France</country></address>
    </author>

    <copyright><year>1996-2008</year><holder>Dynare Team</holder></copyright>

<legalnotice>
<para>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
</para>
<para>
A copy of the license can be found at:
<ulink url="http://www.gnu.org/licenses/fdl.txt">http://www.gnu.org/licenses/fdl.txt</ulink>
</para>
</legalnotice>
<indexterm zone="dynare"><primary>dynare</primary></indexterm>
<indexterm zone="var"><primary>var</primary></indexterm>
<indexterm zone="varexo"><primary>varexo</primary></indexterm>
<indexterm zone="varexo_det"><primary>varexo_det</primary></indexterm>
<indexterm zone="parameters"><primary>parameters</primary></indexterm>
<indexterm zone="model"><primary>model</primary></indexterm>
<indexterm zone="initval"><primary>initval</primary></indexterm>
<indexterm zone="endval"><primary>endval</primary></indexterm>
<indexterm zone="histval"><primary>histval</primary></indexterm>
<indexterm zone="shocks"><primary>shocks</primary></indexterm>
<indexterm zone="periods"><primary>periods</primary></indexterm>
<indexterm zone="simul"><primary>simul</primary></indexterm>
<indexterm zone="check"><primary>check</primary></indexterm>
<indexterm zone="stoch_simul"><primary>stoch_simul</primary></indexterm>
<indexterm zone="estimated_params"><primary>estimated_params</primary></indexterm>
<indexterm zone="estimated_params_init"><primary>estimated_params_init</primary></indexterm>
<indexterm zone="estimated_params_bounds"><primary>estimated_params_bounds</primary></indexterm>
<indexterm zone="varobs"><primary>varobs</primary></indexterm>
<indexterm zone="observation_trends"><primary>observation_trends</primary></indexterm>
<indexterm zone="estimation"><primary>estimation</primary></indexterm>
<indexterm zone="rplot"><primary>rplot</primary></indexterm>
<indexterm zone="dynasave"><primary>dynasave</primary></indexterm>
<indexterm zone="dynatype"><primary>dynatype</primary></indexterm>
<indexterm zone="unit_root_vars"><primary>unit_root_vars</primary></indexterm>
<indexterm zone="optim_weights"><primary>optim_weights</primary></indexterm>
<indexterm zone="osr"><primary>osr</primary></indexterm>
<indexterm zone="osr_params"><primary>osr_params</primary></indexterm>
<indexterm zone="forecast"><primary>forecast</primary></indexterm>
  </bookinfo>

<chapter><title>Introduction</title>

<sect1><title>What is Dynare ?</title>
<para>
Dynare is a pre-processor and a collection of <ulink url="http://www.mathworks.com/products/matlab/"><trademark class="registered">Matlab</trademark></ulink> and <ulink url="http://www.octave.org">GNU Octave</ulink> routines which solve, simulate and estimate non-linear
models with forward looking variables. It is the result of research carried at
<ulink url="http://www.cepremap.ens.fr/">CEPREMAP</ulink> by several people (see Laffargue, 1990, Boucekkine, 1995, and
Juillard, 1996, Collard and Juillard 2001a and 2001b).
</para>
<para>
When the framework is deterministic, Dynare can be used for models with the assumption of perfect
foresight. Typically, the system is supposed to be in a state of
equilibrium before a period <literal>1</literal> when the news of a contemporaneous
or of a future shock is learned by the agents in the model. The
purpose of the simulation is to describe the reaction in anticipation of,
then in reaction to the shock, until the system returns to the old or
to a new state of equilibrium. In most models, this return to
equilibrium is only an asymptotic phenomenon, which one must
approximate by an horizon of simulation far enough in the future.
Another exercise for which Dynare is well suited is to study the
transition path to a new equilibrium following a permanent shock.
</para>
<para>
For deterministic simulations, Dynare uses a Newton-type algorithm, first
proposed by Laffargue (1990), instead of a first order technique like
the one proposed by Fair and Taylor (1983), and used in earlier generation simulation programs. We believe
this approach to be in general both faster and more robust. The
details of the algorithm used in Dynare can be found in Juillard (1996).
</para>
<para>
In a stochastic context, Dynare computes one or several simulations corresponding to a random draw of the shocks. Starting with version 2.3, Dynare uses a second order Taylor approximation of the expectation functions (see Judd, 1996, Collard and Juillard, 2001a, 2001b, and Schmitt-Grohe and Uribe, 2002).
</para>
<para>
Starting with version 3.0, it is possible to use Dynare to estimate model parameters either by maximum likelihood as in Ireland (2004) or using a Bayesian approach as in Rabanal and Rubio-Ramirez (2002), Schorfheide (2000) or Smets and Wouters (2002).
</para>

<para>
Currently the development team of Dynare is composed of S. Adjemian, M. Juillard, O. Kamenik, F. Mihoubi and S. Villemot. Several parts of Dynare use or have strongly benefited from publicly available programs by F. Collard, L. Ingber, P. Klein, M. Ratto, S. Sakata, F. Schorfheide, C. Sims, P. Soederlind and R. Wouters.  
</para>
</sect1>

<sect1><title>Changes since version 3</title>

</sect1>
</chapter>

<chapter><title>Installation and configuration</title>


<sect1><title>Software requirements</title>
<para>
Packaged versions of Dynare are available for <trademark class="registered">Windows</trademark> 98/NT/2000/XP/Vista, <ulink url="http://www.debian.org">Debian GNU/Linux</ulink> and <ulink url="http://www.ubuntu.com/">Ubuntu</ulink>, on Intel/AMD x86 architectures.
Dynare should work on other systems and architectures, but some compilation steps are necessary in that case.
</para>
<para>In order to run Dynare, you need at least one of the following:
<itemizedlist>
<listitem><para><trademark class="registered">Matlab</trademark> version 6.5 or above; note that no toolbox is needed by Dynare,</para></listitem>
<listitem><para>GNU Octave version 3.0.0 or above.</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1><title>Installation of GNU Octave</title>

<para>You can skip this step if you are planning to use only <trademark class="registered">Matlab</trademark> with Dynare.</para>

<para>Please refer to <ulink url="http://www.dynare.org/DynareWiki/DynareOctave">DynareOctave</ulink> on Dynare Wiki for detailed instructions.</para>

</sect1>

<sect1><title>Installation of Dynare</title>

<para>
After installation, Dynare can be used in any directory on your computer. It is best practive to keep your model files in directories different from the one containing the Dynare toolbox. That way you can upgrade Dynare and discard the previous version without having to worry about your own files.
</para>

<sect2><title>On <trademark class="registered">Windows</trademark></title>

<para>Execute the automated installer called <filename>dynare-4.x.y-win32.exe</filename> (where 4.x.y is the version number), and follow the instructions. The default installation directory is <filename>c:\dynare\4.x.y</filename>.</para>

<para>After installation, this directory will contain several sub-directories, among which <filename>matlab</filename>, <filename>mex</filename> and <filename>doc</filename>.</para>

<para>The installer will also add an entry in your Start Menu with a shortcut to documentation files and to the uninstaller.</para>

<para>You can have several versions of Dynare coexisting (for example in <filename>c:\dynare</filename>), as long as you correctly adjust your path settings (see <xref linkend="path_warning" />).</para>

<para>Note that no installer is currently avaible for <trademark class="registered">Windows</trademark> on 64 bits platforms. For the time being, please follow the instructions given in <xref linkend="install_other_systems"/> if you have such a system.</para>
</sect2>

<sect2><title>On Debian GNU/Linux and Ubuntu</title>
<para>Please refer to <ulink url="http://www.dynare.org/DynareWiki/InstallOnDebianOrUbuntu">InstallOnDebianOrUbuntu</ulink> on Dynare Wiki for detailed instructions.</para>

<para>Dynare will be installed under <filename>/usr/lib/dynare</filename>. Documentation will be under <filename>/usr/share/doc/dynare</filename>.</para>
</sect2>

<sect2 id="install_other_systems"><title>For other systems</title>
<para>You need to download Dynare source code from the <ulink url="http://www.dynare.org">Dynare website</ulink> and unpack it somewhere.</para>

<para>Then you will need to recompile the pre-processor and the dynamic loadable libraries. Please refer to <ulink url="http://www.dynare.org/DynareWiki/BuildingPreprocessor">BuildingPreprocessor</ulink> and <ulink url="http://www.dynare.org/DynareWiki/BuildingDlls">BuildingDlls</ulink> on Dynare Wiki.</para>
</sect2>
</sect1>

<sect1><title>Configuration</title>

<sect2><title>For <trademark class="registered">Matlab</trademark></title>

<para>You need to add the <filename>matlab</filename> subdirectory of your Dynare
installation to <trademark class="registered">Matlab</trademark> path. You have two options for doing that:</para>
<itemizedlist>

  <listitem><para>Using the <command>addpath</command> command in the <trademark class="registered">Matlab</trademark> command window:</para>

  <para>Under <trademark class="registered">Windows</trademark>, assuming that you have installed Dynare at the standard location, and replacing "4.x.y" by correct version number, type:</para>
  <programlisting>
  addpath c:\dynare\4.x.y\matlab
  </programlisting>

  <para>Under Debian GNU/Linux or Ubuntu, type:</para>
  <programlisting>
   addpath /usr/lib/dynare/matlab
  </programlisting>

 <para><trademark class="registered">Matlab</trademark> will not remember this setting next time you run it, and you will have
 to do it again.</para>
 </listitem>
  <listitem><para>Via the menu entries:</para>
<para>Select the "Set Path" entry in the "File" menu, then click on "Add
  Folder...", and select the <filename>matlab</filename> subdirectory of your Dynare
  installation. Note that you <emphasis>should not</emphasis> use "Add with Subfolders...". Apply
  the settings by clicking on "Save". Note that Matlab will remember this
  setting next time you run it.</para></listitem>
</itemizedlist>
</sect2>

<sect2><title>For GNU Octave</title>

<para>You need to add the <filename>matlab</filename> subdirectory of your Dynare
installation to Octave path, using the <command>addpath</command> at the Octave command prompt.</para>

<para>Under <trademark class="registered">Windows</trademark>, assuming that you have installed Dynare at the standard location, and replacing "4.x.y" by correct version number, type:</para>
<programlisting>
  addpath c:\dynare\4.x.y\matlab
</programlisting>

<para>Under Debian GNU/Linux or Ubuntu, type:</para>
<programlisting>
  addpath /usr/lib/dynare/matlab
</programlisting>

<para>You will also want to tell to Octave to accept the short syntax (without parentheses and quotes) for the <command>dynare</command> command, by typing:</para>
<programlisting>
  mark_as_command dynare
</programlisting>

<para>If you don't want to type these two commands every time you run Octave,
you can put them in a file called <filename>.octaverc</filename> in your home directory (under <trademark class="registered">Windows</trademark> this will generally by <filename>c:\Documents and Settings\USERNAME\</filename>). This file is run by Octave at every startup.</para>
</sect2>

<sect2 id="path_warning"><title>Some words of warning</title>

<para>You should be very careful about the content of you <trademark class="registered">Matlab</trademark> or Octave path. You can display its content by simply typing <command>path</command> in the command window.</para>

<para>The path should normally contain system directories of <trademark class="registered">Matlab</trademark> or Octave, and the <filename>matlab</filename> subdirectory of your Dynare installation. It should not contain any other Dynare-related directory, from another Dynare version of from the version you are using. However, note that Dynare will automatically add one (and only one) of the <filename>mex/2007a</filename>, <filename>mex/2007b</filename>, and <filename>mex/octave</filename> subdirectories, depending on your installation.</para>

<para>You have to be aware that adding other directories to your path can potentially create problems, if some of your M-files have the same names than Dynare files. Your files would then override Dynare files, and make Dynare unusable.</para>
</sect2>

</sect1>
</chapter>

<chapter><title>Dynare invocation</title>

<para>
In order to give instructions to Dynare, the user has to write a <emphasis>model file</emphasis> whose filename extension must be <filename class="extension">.mod</filename>. This file contains the description of the model and the computing tasks required by the user. Its contents is described in <xref linkend="modfile"/>.
</para>

<para>Once the model file is written, Dynare is invoked using the <command>dynare</command> command at the <trademark class="registered">Matlab</trademark> or Octave prompt (with the filename of the <filename class="extension">.mod</filename> given as argument).</para>

<para>
In practice, the handling of the model file is done in two
steps: in the first one, the model and the processing instructions
written by the user in a <emphasis>model file</emphasis> are
interpreted and the proper <trademark class="registered">Matlab</trademark> or GNU Octave instructions are generated; in the
second step, the program actually runs the computations. Boths steps are triggered automatically by the <command>dynare</command> command.
</para>

<refentry id="dynare">
  <refmeta>
    <refentrytitle>dynare</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynare</refname>
    <refpurpose>executes Dynare</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynare</command>
      <arg choice="plain">
      <replaceable>FILENAME</replaceable>[.mod]
      </arg>
      <arg><option>noclearall</option></arg>
      <arg><option>savemacro</option></arg>
      <arg><option>debug</option></arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynare</command> executes instruction included in <replaceable>FILENAME</replaceable><filename class="extension">.mod</filename>.
This user-supplied file contains the model and the processing instructions, as described in <xref linkend="modfile"/>.
</para>
</refsect1>

<refsect1><title>Details</title>
<para>
<command>dynare</command> begins by launching the preprocessor on the <filename class="extension">.mod</filename> file.

By default (unless any of <option>use_dll</option>, <option>sparse</option> or <option>sparse_dll</option> options have been given to <xref linkend="model"/>), the preprocessor creates three intermediary files:
<itemizedlist spacing='compact'>
  <listitem><para><replaceable>FILENAME</replaceable><filename>.m</filename>: contains variable declarations, and computing tasks</para></listitem>
  <listitem><para><replaceable>FILENAME</replaceable><filename>_dynamic.m</filename>: contains the dynamic model equations</para></listitem>
  <listitem><para><replaceable>FILENAME</replaceable><filename>_static.m</filename>: contains the long run static model equations</para></listitem>
</itemizedlist>
These files may be looked at to understand errors reported at the simulation stage.
</para>
<para><command>dynare</command> will then run the computing tasks by executing <replaceable>FILENAME</replaceable><filename>.m</filename>.</para>
</refsect1>

<refsect1><title>Options</title>

  <itemizedlist spacing='compact'>
    <listitem><para><option>noclearall</option>: by default, <command>dynare</command> will issue a <command>clear all</command> command to <trademark class="registered">Matlab</trademark> or Octave, thereby deleting all workspace variables; this options instructs <command>dynare</command> not to clear the workspace</para></listitem>
    <listitem><para><option>savemacro</option>: instructs <command>dynare</command> to save the intermediary file which is obtained after macro-processing (see <xref linkend="macrolanguage"/>); the saved output will go in <replaceable>FILENAME</replaceable><filename>-macroexp.mod</filename></para></listitem>
    <listitem><para><option>debug</option>: instructs the preprocessor to write some debugging information about the scanning and parsing of the <filename class="extension">.mod</filename> file</para></listitem>
  </itemizedlist>

</refsect1>

<refsect1><title>Output</title>
<para>
Depending on the computing tasks requested in the <filename class="extension">.mod</filename> file, executing command <command>dynare</command> will leave in the workspace variables containing results available for further processing. More details are given under the relevant computing tasks.
</para>

<para>
The <varname>oo_</varname> structure is also saved in a file called <replaceable>FILENAME</replaceable><filename>_results.mat</filename>.
</para>
</refsect1>

<refsect1><title>Examples</title>
<programlisting>
dynare ramst
dynare ramst.mod savemacro
</programlisting>
</refsect1>
</refentry>
</chapter>

<chapter id="modfile"><title>The Model file</title>
<para>
Dynare commands are either single instructions or a block of instructions. Each single instruction and each element of a block is terminated by a semicolon (<command>;</command>). Blocks of instructions are terminated by <command>end;</command>.
</para>

<para>
Most Dynare commands have arguments and several accept options, indicated in parentheses after the command keyword.
</para>

<para id="conventions" xreflabel="Conventions">
In the description of Dynare commands, the following conventions are observed:
<itemizedlist>
<listitem><para>optional arguments or options are indicated between square brackets <command>[]</command></para></listitem>
<listitem><para>repreated arguments are indicated by ellipses <command>...</command></para></listitem>
<listitem><para><replaceable>INTEGER</replaceable> indicates an integer number</para></listitem>
<listitem><para><replaceable>DOUBLE</replaceable> indicates a double precision number. The following syntaxes are valid: 1.1e3, 1.1E3, 1.1d3, 1.1D3</para></listitem>
<listitem><para><replaceable>EXPRESSION</replaceable> indicates a mathematical expression valid outside the model description (see <xref linkend="expressions"/>)</para></listitem>
<listitem><para><replaceable>MODEL_EXPRESSION</replaceable> indicates a mathematical expression valid in the model description (see <xref linkend="expressions"/> and <xref linkend="model"/>)</para></listitem>
<listitem><para><replaceable>VARIABLE_NAME</replaceable> indicates a variable name starting with an alphabetical character and can't contain ()+-*/^=!;:@#. or accentuated characters</para></listitem>
<listitem><para><replaceable>PARAMETER_NAME</replaceable> indicates a parameter name starting with an alphabetical character and can't contain ()+-*/^=!;:@#. or accentuated characters</para></listitem>
<listitem><para><replaceable>FILENAME</replaceable> indicates a file name valid in the underlying operating system (<trademark class="registered">Windows</trademark>, GNU/Linux, ...)</para></listitem>
</itemizedlist>
</para>

<sect1><title>Variable declarations</title>

<para>Declarations of variables and parameters are made with the following commands:</para>
<itemizedlist>
<listitem><para><xref linkend='var'/></para></listitem>
<listitem><para><xref linkend='varexo'/></para></listitem>
<listitem><para><xref linkend='varexo_det'/></para></listitem>
<listitem><para><xref linkend='parameters'/></para></listitem>
</itemizedlist>

<refentry id="var">
  <refmeta>
    <refentrytitle>var</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>var</refname>
    <refpurpose>declares endogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>var</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This required command declares the endogenous variables in the model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>.
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
var c gnp q1 q2;
</programlisting>
</refsect1>
</refentry>

<refentry id="varexo">
  <refmeta>
    <refentrytitle>varexo</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varexo</refname>
    <refpurpose>declares exogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varexo</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
    <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This optional command declares the exogenous variables in the model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>.
</para>
<para>
Exogenous variables are required if the user wants to be able to apply shocks to her model. 
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
varexo m gov;
</programlisting>
</refsect1>
</refentry>

<refentry id="varexo_det">
  <refmeta>
    <refentrytitle>varexo_det</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varexo_det</refname>
    <refpurpose>declares exogenous deterministic variables in a stochastic  model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varexo_det</command>
      <arg choice="plain">
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This optional command declares exogenous deterministic variables in a stochastic model. See <xref linkend="conventions"/> for the syntax of <replaceable>VARIABLE_NAME</replaceable>.
</para>
<para>It is possible to mix deterministic and stochastic shocks to build models where agents know from the start of the simulation about future exogenous changes. In that case <xref linkend="stoch_simul"/> will compute the rational expectation solution adding future information to the state space (nothing is shown in the output of <xref linkend="stoch_simul"/>) and <xref linkend="forecast"/> will compute a simulation conditional on initial conditions and future information.
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
varexo m gov;
varexo_det tau;
</programlisting>
</refsect1>
</refentry>

<refentry id="parameters">
  <refmeta>
    <refentrytitle>parameters</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>parameters</refname>
    <refpurpose>declares parameters</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>parameters</command>
      <arg choice="plain">
	      <replaceable>PARAMETER_NAME</replaceable>
      </arg>
      <arg rep="repeat"><arg>,</arg>
	      <replaceable>PARAMETER_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This optional command declares parameters used in the model, in variable initialization or in shocks declarations. See <xref linkend="conventions"/> for the syntax of <replaceable>PARAMETER_NAME</replaceable>.
</para>
<para>The parameters must subsequently be assigned values, see <xref linkend="param_init"/>.
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
parameters alpha, bet;
</programlisting>
</refsect1>
</refentry>
</sect1>

<sect1 id="expressions"><title>Expressions</title>

  <para>Dynare distinguishes between two types of mathematical expressions: those that are used to describe the model, and those that are used outside the model block (<foreignphrase>e.g.</foreignphrase> for initializing parameters or variables, or as command options). In this manual, those two types of expressions are respectively denoted by <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>.</para>

  <para>Unlike <trademark class="registered">Matlab</trademark> or Octave expressions, Dynare expressions are necessarily scalar ones: they cannot contain matrices or evaluate to matrices<footnote><para>Note that arbitrary <trademark class="registered">Matlab</trademark> or Octave expressions can be put in a <filename class="extension">.mod</filename> file, but those expressions have to be on separate lines, generally at the end of the file for post-processing purposes. They are not interpreted by Dynare, and are simply passed on unmodified to <trademark class="registered">Matlab</trademark> or Octave. Those constructions are not addresses in this section.</para></footnote>.</para>

  <para>Expressions can be constructed using integers (<replaceable>INTEGER</replaceable>), floating point numbers (<replaceable>DOUBLE</replaceable>), parameter names, variable names, operators and functions.</para>

  <sect2>
    <title>Parameters and variables</title>

    <para>Parameters and variables can be introduced in expressions by simply typing their names. The semantics of parameters and variables is quite different whether they are used inside or outside the model block.</para>

    <sect3>
      <title>Inside the model</title>

      <para>Parameters used inside the model either refer to the value given through <link linkend="param_init">parameter initialization</link> (and possiblity <xref linkend="homotopy_setup"/>) when doing a simulation, or are the estimated variables when doing an estimation.</para>

      <para>Variables used in a <replaceable>MODEL_EXPRESSION</replaceable> denote <emphasis>current period</emphasis> values when neither a lead or a lag is given. A lead or a lag can be given by enclosing an integer between parenthesis just after the variable name: a positive integer means a lead, a negative one means a lag. For example, if <literal>c</literal> is an endogenous variable, then <literal>c(+1)</literal> is the variable one period ahead, and <literal>c(-2)</literal> is the variable two periods before.</para>

      <para>Leads and lags are primarily used for endogenous variables. They can be used for exogenous variables under some conditions (TO BE EXPLICITED). They are forbidden for parameters and for local model variables (see <xref linkend="model"/>).</para>

    </sect3>

    <sect3>
      <title>Outside the model</title>
      <para>When used in an expression outside the model block, a parameter or a variable simply refers to the last value given to that variable. More precisely, for a parameter it refers to the value given in the corresponding <link linkend="param_init">parameter initialization</link>; for an endogenous or exogenous variable, it refers to the value given in the most recent <xref linkend="initval"/> or <xref linkend="endval"/> block.</para>
    </sect3>

  </sect2>

  <sect2><title>Operators</title>
    <para>The following operators are allowed in both <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>:
      <itemizedlist>
        <listitem><para>binary arithmetic operators: <literal>+</literal>, <literal>-</literal>, <literal>*</literal>, <literal>/</literal>, <literal>^</literal></para></listitem>
        <listitem><para>unary arithmetic operators: <literal>+</literal>, <literal>-</literal></para></listitem>
        <listitem><para>binary comparison operators (which evaluate to either <literal>0</literal> or <literal>1</literal>): <literal>&lt;</literal>, <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>, <literal>==</literal>, <literal>!=</literal></para></listitem>
      </itemizedlist>
    </para>
  </sect2>

  <sect2><title>Functions</title>
    <para>The following standard functions are allowed in both <replaceable>MODEL_EXPRESSION</replaceable> and <replaceable>EXPRESSION</replaceable>:
      <itemizedlist>
        <listitem><para>exponential: <literal>exp()</literal></para></listitem>
        <listitem><para>natural logarithm: <literal>log()</literal> (aliased as <literal>ln()</literal>)</para></listitem>
        <listitem><para>base 10 logarithm: <literal>log10()</literal></para></listitem>
        <listitem><para>square root: <literal>sqrt()</literal></para></listitem>
        <listitem><para>trigonometric functions: <literal>sin()</literal>, <literal>cos()</literal>, <literal>tan()</literal>, <literal>asin()</literal>, <literal>acos()</literal>, <literal>atan()</literal></para></listitem>
        <listitem><para>TO BE COMPLETED</para></listitem>
      </itemizedlist>
    </para>
    <para>Unknown functions allowed (under some conditions) in expressions outside model block.</para>
</sect2>

</sect1>

<sect1 id="param_init"><title>Parameter initialization</title>

<para>The syntax is the following:</para>
<cmdsynopsis>
  <replaceable>PARAMETER_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
</cmdsynopsis>

<para>Examples:</para>

<programlisting>
parameters alpha, bet;

beta = 0.99;
alpha = 0.36;
A = 1-alpha*beta;
</programlisting>

</sect1>

<sect1><title>Model declaration</title>

<para>The model is declared inside a <xref linkend="model"/> block.</para>

<refentry id="model">
  <refmeta>
    <refentrytitle>model</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>model</refname>
    <refpurpose>declares the model equations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>model</command>
      <arg>
	(linear)
      </arg>
      <arg choice="plain">
      ;
      </arg><sbr/>
      <arg choice="plain">
	<synopfragmentref linkend="pound_exp">MATLAB EXPRESSION</synopfragmentref>;
      </arg><sbr/>
      <arg rep="repeat">
	<synopfragmentref linkend="pound_exp">MATLAB EXPRESSION</synopfragmentref>;
      </arg><sbr/>
      <arg choice="plain">
	end;
      </arg>

      <arg choice="plain">
	<synopfragmentref linkend="eq">EQUATION</synopfragmentref>;
      </arg><sbr/>
      <arg rep="repeat">
	<synopfragmentref linkend="eq">EQUATION</synopfragmentref>;
      </arg><sbr/>
      <arg choice="plain">
	end;
      </arg>

      <synopfragment id="pound_exp">
	<arg choice="plain">#<replaceable>EXPRESSION</replaceable></arg>
	<arg>= #<replaceable>EXPRESSION</replaceable></arg>
	<arg choice="plain">;</arg>
      </synopfragment>

      <synopfragment id="eq">
	<arg choice="plain"><replaceable>EXPRESSION</replaceable></arg>
	<arg>= <replaceable>EXPRESSION</replaceable></arg>
	<arg choice="plain">;</arg>
      </synopfragment>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
The equations of the model are written in a block delimited by <command>model;</command> and <command>end;</command>.
</para>
<para>
There must be as many equations as there are endogenous variables in the model, except when used to compute the unconstrained optimal policy with <xref linkend="ramsey_policy"/>. The lead and lag of the variables are written in parenthesis immediately after the variable name. Leads or lags of more than one period are allowed. Only some elementary functions are allowed. Each equation must be terminated by a semicolon (;).
</para>
<para>
When the equations are written in homogenous form, it is possible to omit the "= 0" part and write only the left hand side of the equation.
</para>
<para>
It is possible to include arbitrary Matlab expressions in a model. It must be preceeded by a pound sign (#) as the first character of the line. This is particularily usefull to declare tansformation of parameters for estimation purpose (see <xref linkend="estimated_params"/>).
</para>

<para>
The option <command>linear</command> declares the model as being linear. It avoids to have to declare initial values for computing the steady state and it sets automatically <command>order=1</command> in <command>stoch_simul</command>.
</para>
</refsect1>

<refsect1><title>Example 1</title>
<programlisting>
model;
c =  - k + aa*x*k(-1)^alph + (1-delt)*k(-1);
c^(-gam) = (aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam)/(1+bet);
end;
</programlisting>
</refsect1>

<refsect1><title>Example 2</title>
<programlisting>
model;
c + k - aa*x*k(-1)^alph - (1-delt)*k(-1);
c^(-gam) - (aa*alph*x(+1)*k^(alph-1) + 1 - delt)*c(+1)^(-gam)/(1+bet);
end;
</programlisting>
</refsect1>

<refsect1><title>Example 3</title>
<programlisting>
model(linear);
# b = 1/c;
x = a*x(-1)+b*y(+1)+e_x;
y = d*y(-1)+e_y;
end;
</programlisting>
</refsect1>
</refentry>
</sect1>

<sect1><title>Initial and terminal conditions</title>
<para>
In many contexts, it is necessary to compute the steady state of a non-linear model <xref linkend='initval'/> specifies then numerical initial values for the non-linear solver.
</para>
<para>
Used in perfect foresight mode, the types of forward-loking models for which Dynare was designed require both initial and terminal conditions. Most often these initial and terminal conditions are static equilibria, but not necessarily. 
</para>
<para>
One typical application is to consider an economy at the equilibrium, trigger a shock in first period, and study the trajectory of return at the initial equilbrium. To do that, one needs <xref linkend='initval'/> and <xref linkend='shocks'/>(see next section). 
</para>
<para>
Another one is to study, how an economy, starting from arbitrary initial conditions converges toward equilibrium. To do that, one needs <xref linkend='initval'/> and <xref linkend='endval'/>; 
</para>
<para>
For models with lags on more than one period, the command <xref linkend='histval'/> permits to specify different historical initial values in different periods. 
</para>
<itemizedlist>
<listitem><para><xref linkend='initval'/></para></listitem>
<listitem><para><xref linkend='initval_file'/></para></listitem>
<listitem><para><xref linkend='endval'/></para></listitem>
<listitem><para><xref linkend='histval'/></para></listitem>
</itemizedlist>

<refentry id="initval">
  <refmeta>
    <refentrytitle>initval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>initval</refname>
    <refpurpose>specifies numerical starting values for finding the steady state and/or initial values for simulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>initval;</command><sbr/>
      <arg choice="plain">
	<replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg><sbr/>
	<arg rep="repeat">
	<replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	  </arg><sbr/>
	  <arg choice="plain">
	    end;
	  </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<replaceable>EXPRESSION</replaceable> is any valid expression returning a numerical value and can contain already initialized variable names.
</para>
<para>
The <command>initval;</command> ... <command>end;</command> block serves two purposes. It set the initial and, possibly, terminal conditions for the simulation and provides numerical initialization for various computation tasks (<xref linkend='steady'/>, <xref linkend='simul'/>, <xref linkend='stoch_simul'/>).  
</para>
<para>
Theoreticaly, initial conditions are only necessary for lagged variables. However, as <command>initval</command> provides also numerical initialization, it is necessary to provide values for all variables in the model, except if the model is declared as linear.
</para>
<para>
For stochastic models, it isn't necessary to delcare 0 as initial values for exogneous stochastic variables as it is the only possible value.
</para>
<para>
When the <command>initval</command> block is followed by the command <xref linkend='steady'/>, it is not necessary to provide exact initialization values for the endogenous variables. <xref linkend='steady'/> will use the values provided in the <command>initval</command> block as initial guess in the non-linear equation solver and computes exact values for the endogenous variables at the steady state. The steady state is defined by keeping constant the value of the exogenous variables.  
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
initval;
c = 1.2;
k = 12;
x = 1;
end;

steady;
</programlisting>
</refsect1>
</refentry>

<refentry id="initval_file">
  <refmeta>
    <refentrytitle>initval_file</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>initval_file</refname>
    <refpurpose>use an external file for specifying initial values (for steady-state computation or for simulations)</refpurpose>
  </refnamediv>
</refentry>

<refentry id="endval">
  <refmeta>
    <refentrytitle>endval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>endval</refname>
    <refpurpose>specifies terminal values for deterministic simulations</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>endval;</command><sbr/>
      <arg choice="plain">
	<replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg><sbr/>
	<arg rep="repeat">
	<replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	  </arg><sbr/>
	  <arg choice="plain">
	    end;
	  </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<replaceable>EXPRESSION</replaceable> is any valid expression returning a numerical value and can contain already initialized variable names.
</para>
<para>
The optional <command>endval;</command> ... <command>end;</command> block serves two purposes. It set the terminal conditions for the simulation with the LBJ alogrithm, when those differ from the initial conditions. When it is the case, the <command>endval</command> block also provides the numerical initialization for various computation tasks (<xref linkend='steady'/>, <xref linkend='simul'/>), starting in period 1.  
</para>
<para>
Theoreticaly, terminal conditions are required in the LBJ algorithm only for forward variables. However, as <command>endval</command> provides also numerical initialization, it is necessary to provide values for all variables in the model.
</para>
<para>
When the <command>endval</command> block is followed by the command <xref linkend='steady'/>, it is not necessary to provide exact values for the endogenous variables. <xref linkend='steady'/> will use the values provided in the <command>endval</command> block as initial guess in the non-linear equation solver and computes exact values for the endogenous variables at the steady state. The steady state is defined by keeping constant the value of the exogenous variables.  
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
var c k;
varexo x;
...
initval;
c = 1.2;
k = 12;
x = 1;
end;

steady;

endval;
c = 2;
k = 20;
x = 2;
end;

steady;
</programlisting>
<para>
The initial equilibrium is comptuted by <xref linkend='steady'/> for x=1, and the terminal one, for x=2.
</para>
</refsect1>
</refentry>

<refentry id="histval">
  <refmeta>
    <refentrytitle>histval</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>histval</refname>
    <refpurpose>specifies historical values before the start of a simulation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>histval;</command><sbr/>
      <arg choice="plain">
	<replaceable>VARIABLE_NAME</replaceable> (<replaceable>INTEGER</replaceable>) = <replaceable>EXPRESSION</replaceable>;
	</arg><sbr/>
	<arg rep="repeat">
	<replaceable>VARIABLE_NAME</replaceable> (<replaceable>INTEGER</replaceable>) = <replaceable>EXPRESSION</replaceable>;
	  </arg><sbr/>
	  <arg choice="plain">
	    end;
	  </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<replaceable>EXPRESSION</replaceable> is any valid expression returning a numerical value and can contain already initialized variable names.
</para>
<para>
In models with lags on more than one period, the optional <command>histval;</command> ... <command>end;</command> block permits to specify different historical initial values for different periods.
</para>
<para>
By convention in Dynare, period 1 is the first period of the simulation. Going backward in time, the first period before the start of the simulation is period 0, then period -1, and so on.
</para>
<para>
If your lagged variables are linked by identities, be careful to satisfy these identities when you set historical initial values.
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
var x y;
varexo e;

model;
x = y(-1)^alpha*y(-2)^(1-alpha)+e;
...
end;

initval;
x = 1;
y = 1;
e = 0.5;
end;

steady;

histval;
y(0) = 1.1;
y(-1) = 0.9;
end;
</programlisting>
</refsect1>

</refentry>
</sect1>

<sect1><title>Shocks on exogenous variables</title>
<para>
In a deterministic context, when one wants to study the transition of one equilibrium position to another, it is equivalent to analyze the consequences of a permanent shock and this in done in Dynare through the proper use of <xref linkend='initval'/> and <xref linkend='endval'/>.
</para>
<para>
Another typical experiment is to study the effects of a temporary shock after which the system goes back to the original equilibrium (if the model is stable ...). A temporary shock is a temporary change of value of one or several exogenous variables in the model. Temporary shocks are specified with the command <xref linkend='shocks'/>.
</para>
<para>
In a stochastic framework, the exogenous variables take random values in each period. In Dynare, these random values follow a normal distribution with zero mean, but it belongs to the user to specify the variability of these shocks. The non-zero elements of the matrix of variance-covariance of the shocks can be entered with the <xref linkend='shocks'/> command. Or, the entire matrix can be direclty entered with <xref linkend='Sigma_e'/>. Note that, starting with version 2.5.2, the direct specification of the <emphasis>internal</emphasis> matrix <varname>Sigma_e_</varname>, prone to errors, is discouraged.
</para>
<para>
If the variance of an exogenous variable is set to zero, this variable will appear in the report on policy and transition functions, but isn't used in the computation of moments and of Impulse Response Functions. Setting a variance to zero is an easy way of removing an exogenous shock.
</para>
<itemizedlist>
<listitem><para><xref linkend='shocks'/></para></listitem>
<listitem><para><xref linkend='mshocks'/></para></listitem>
<listitem><para><xref linkend='Sigma_e'/> (deprecated)</para></listitem>
</itemizedlist>

<refentry id="shocks">
  <refmeta>
    <refentrytitle>shocks</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>shocks</refname>
    <refpurpose>specifies shocks on deterministic or stochastic exogenous variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>shocks</command>
      <arg>(<arg rep="repeat" choice="plain"><replaceable>OPTION</replaceable>,</arg>);</arg><sbr/>
      <group choice="plain">
	<arg choice="plain">
	  <synopfragmentref linkend="det_shock">DETERMINISTIC SHOCK STATEMENT</synopfragmentref>
	</arg>
	<arg choice="plain">
	  <synopfragmentref linkend="st_shock">STOCHASTIC SHOCK STATEMENT</synopfragmentref>
	</arg>
      </group><sbr/>
      <group rep="repeat">
	<arg choice="plain">
	  <synopfragmentref linkend="det_shock">DETERMINISTIC SHOCK STATEMENT</synopfragmentref>
	</arg>
	<arg choice="plain">
	  <synopfragmentref linkend="st_shock">STOCHASTIC SHOCK STATEMENT</synopfragmentref>
	</arg>
      </group><sbr/>
      <arg choice ="plain">end;</arg>
      <synopfragment id="det_shock">
	<arg choice="plain">var <replaceable>VARIABLE_NAME</replaceable>;</arg>
	<arg choice="plain">periods <synopfragmentref linkend="period_st">PERIOD STATEMENT</synopfragmentref>;</arg>
	<arg choice="plain">values EXPRESSION;</arg>
      </synopfragment>
      <synopfragment id="period_st">
	    <arg choice="plain"><replaceable>INTEGER</replaceable></arg>
	    <arg>: <replaceable>INTEGER</replaceable></arg>
	    <arg rep="repeat"><replaceable>INTEGER</replaceable>
	    <arg>: <replaceable>INTEGER</replaceable></arg>
	    </arg><arg choice="plain">;</arg>
      </synopfragment>
      <synopfragment id="st_shock">
	<group choice="plain">
	  <arg choice="plain">
	    <synopfragmentref linkend="var_st">VARIANCE STATEMENT</synopfragmentref>
	  </arg>
	  <arg choice="plain">
	    <synopfragmentref linkend="covar_st">COVARIANCE STATEMENT</synopfragmentref>
	  </arg>
	  <arg choice="plain">
	    <synopfragmentref linkend="stderr_st">STANDARD ERROR STATEMENT</synopfragmentref>
	  </arg>
	</group>
      </synopfragment>
      <synopfragment id="var_st">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
      <synopfragment id="covar_st">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable> , <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
      <synopfragment id="stderr_st">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable>; stderr <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
    </cmdsynopsis>
  </refsynopsisdiv>
<refsect1><title>Options</title>
<itemizedlist spacing='compact'>
<listitem>
  <para><command>shocks_file</command> = FILENAME: reads sequence of deterministic shocks from FILENAME. It can be either a *.m or a *.mat file. The file must create vectors with the same names as the deterministic exogenous variables.</para>
</listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Description</title>
<refsect2><title>In deterministic context</title>
<para>
For deterministic simulations, the <command>shocks</command> block specifies temporary changes in the value of an exogenous variables. For permanent shocks, use an <xref linkend='endval'/> block.
</para>

<para>
  When specifying shocks on several periods, the <command>values</command> <replaceable>EXPRESSION</replaceable> must return either a scalar value common to all periods with a shock or a column vector with as many elements as there are periods in the <command>periods</command> statement just before it.
</para>

<refsect3><title>Example</title> 
<programlisting>
shocks;
var e;
periods 1;
values 0.5;
var u;
periods 4:5;
values 0;
var v;
periods 4 5 6;
values 0;
var u;
periods 4  5   6;
values  1 1.1 0.9;
end;
</programlisting>
</refsect3>
</refsect2>

<refsect2><title>In stochastic context</title>
<para>
For stochastic simulations (available only in the Matlab or Scilab versions), the <command>shocks</command> block specifies the non zero elements of the covariance matrix of the shocks.
</para>

<refsect3><title>Example</title> 
<programlisting>
shocks;
var e = 0.000081;
var e,u = phi*0.009*0.009;
var u = 0.000081;
var v; stderr 0.009;
end;
</programlisting>
</refsect3>
<refsect3><title>See also</title>
<para>
<command>Sigma_e</command>
</para>
</refsect3>
</refsect2>

<refsect2><title>Mixing determininistic and stochastic shocks</title>
<para>It is possible to mix deterministic and stochastic shocks to build models where agents know from the start of the simulation about future exogenous changes. In that case <xref linkend="stoch_simul"/> will compute the rational expectation solution adding future information to the state space (nothing is shown in the output of <xref linkend="stoch_simul"/>) and <xref linkend="forecast"/> will compute a simulation conditional on initial  conditions and future information.
</para>

<refsect3><title>Example</title>
<informalexample>
  <programlisting>
varexo_det tau;
varexo e;

...

shocks;
var e; stderr 0.01;
var tau;
periods 1:9;
values -0.15;
end;

stoch_simul(irf=0);

forecast;
  </programlisting>
</informalexample>
</refsect3>
</refsect2>

</refsect1>
</refentry>

<refentry id="mshocks">
  <refmeta>
    <refentrytitle>mshocks</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>mshocks</refname>
    <refpurpose>specifies multiplicative shocks on deterministic or stochastic exogenous variables</refpurpose>
  </refnamediv>
</refentry>

<refentry id="Sigma_e">
  <refmeta>
    <refentrytitle>Sigma_e</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>Sigma_e</refname>
    <refpurpose>specifies directly the covariance matrix of the stochastic shocks</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>Sigma_e</command>
      <arg choice="plain">
	= [<synopfragmentref linkend="matrix_el">MATRIX ELEMENT</synopfragmentref>
	<arg rep="repeat"><arg>,</arg><synopfragmentref linkend="matrix_el">MATRIX ELEMENT</synopfragmentref></arg>
	<arg rep="repeat"><arg choice="plain">;</arg><synopfragmentref linkend="matrix_el">MATRIX ELEMENT</synopfragmentref></arg>];
      </arg>

      <synopfragment id="matrix_el">
	<group choice="plain">
	  <arg choice="plain">
	    <replaceable>INTEGER</replaceable>
	  </arg>
	  <arg choice="plain">
	    <replaceable>DOUBLE</replaceable>
	  </arg>
	  <arg choice="plain">
	    (<replaceable>EXPRESSION</replaceable>)
	  </arg>
	</group>
      </synopfragment>
    </cmdsynopsis>
    <para>
      WARNING: the matrix elements are actually written beween square brackets ([]). Here, the initial [ and final ] don't have the meaning of "optional element" as elsewhere.
    </para>
  </refsynopsisdiv>


<refsect1><title>Description</title>

<para>
The matrix of variance-covariance of the shocks can be directly specified as a upper (or lower) triangular matrix. Dynare builds the corresponding symmetrix matrix. Each row of the triangular matrix, except the last one, must be terminated by a semi-colon ';'. For a given element, an <replaceable>EXPRESSION</replaceable> using predefined parameters is allowed but must be placed between parentheses. THE ORDER OF THE COVARIANCES IN THE MATRIX IS THE SAME AS THE ONE USED IN THE VAREXO DECLARATION.
</para>
<note>
<para>In previous versions, it was possible to directly set Dynare's internal covariance matrix <varname>Sigma_e_</varname>. This is still possible for compatibility with older <filename class="extension">.mod</filename> files, but STRONGLY DISCOURAGED as too prone to error. When setting <varname>Sigma_e_</varname> directly, the order of the exogenous shocks is the ALPHABETICAL order of their names.
</para>
</note>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
varexo u, e;
...
Sigma_e = [ 0.81 (phi*0.9*0.009); 0.000081];
</programlisting>
<para>
where the variance of <varname>u</varname> is 0.81, the variance of <varname>e</varname>, 0.000081, and the correlation between <varname>e</varname> and <varname>u</varname> is <varname>phi</varname>.
</para>
</refsect1>
</refentry>
</sect1>

<sect1><title>Other general declarations</title>

<itemizedlist>
<listitem><para><xref linkend='dsample'/></para></listitem>
<listitem><para><xref linkend='periods'/> (deprecated)</para></listitem>
</itemizedlist>

<refentry id="dsample">
  <refmeta>
    <refentrytitle>dsample</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dsample</refname>
    <refpurpose>reduces the number of periods considered in subsequent output commands</refpurpose>
  </refnamediv>
</refentry>

<refentry id="periods">
  <refmeta>
    <refentrytitle>periods</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>periods</refname>
    <refpurpose>specifies the number of simulation periods</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>periods</command> <arg choice="plain">
      <replaceable>INTEGER</replaceable>;
      </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
This command is now deprecated (but will still work for older model files). It is not necessary when no simulation is performed and is replaced by an option <option>periods</option> in <xref linkend="simul"/> and <xref linkend="stoch_simul"/>.
</para>
<para>
Sets the number of periods in the simulation. The periods are numbered from 1 to <replaceable>INTEGER</replaceable>. In perfect foresight simulations, it is assumed that all future events are perfectly known at the beginning of period 1.
</para>
</refsect1>

<refsect1><title>Example</title>
<programlisting>
periods 100;
</programlisting>
</refsect1>
</refentry>

</sect1>

<sect1><title>Solving and simulating</title>
<para>
Dynare has special commands for the computation of the static equilibrium of the model (<xref linkend='steady'/>, of the eigenvalues of the linearized model (<xref linkend='check'/>) for dynamics local analysis, of a deterministic simulation (<xref linkend='simul'/>) and for solving and/or simulating a stochastic model (<xref linkend='stoch_simul'/>).
</para>
<itemizedlist>
<listitem><para><xref linkend='steady'/></para></listitem>
<listitem><para><xref linkend='homotopy_setup'/></para></listitem>
<listitem><para><xref linkend='check'/></para></listitem>
<listitem><para><xref linkend='forecast'/></para></listitem>
<listitem><para><xref linkend='simul'/></para></listitem>
<listitem><para><xref linkend='stoch_simul'/></para></listitem>
</itemizedlist>

<refentry id="steady">
  <refmeta>
    <refentrytitle>steady</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>steady</refname>
    <refpurpose>copmutes the steady state of a model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>steady</command>
      <arg>
      (solve_algo = 
      <group choice="plain">
	<arg choice="plain">0</arg>
	<arg choice="plain">1</arg>
	<arg choice="plain">2</arg>
      </group>)
      </arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<itemizedlist spacing='compact'>
<listitem><para><command>solve_algo = 0</command>: uses Matlab Optimization Toolbox FSOLVE</para></listitem>
<listitem><para><command>solve_algo = 1</command>: uses Dynare's own nonlinear equation solver</para></listitem>
<listitem><para><command>solve_algo = 2</command>: splits the model into recursive blocks and solves each block in turn. (Thanks to Manfred Gilli for showing me Matlab's function DMPERM) (this is the default since Dynare version 3.046).</para>
</listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Description</title>

<para>
Computes the equilibrium value of the endogenous variables for the value of the exogenous variables specified in the previous <xref linkend='initval'/> or <xref linkend='endval'/> block.
</para>
<para>
<command>steady</command> uses an iterative procedure and takes as initial guess the value of the endogenous variables set in the previous <xref linkend='initval'/> or <xref linkend='endval'/> block.
</para>
<para>
For complicated models, finding good numerical initial values for the endogenous variables is the trickiest part of finding the equilibrium of that model. Often, it is better to start with a smaller model and add new variables one by one.
</para>

<para>If you know how to compute the steady state for your model, you can provide a Matlab function doing the computation instead of using <command>steady</command>. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

</refsect1>

<refsect1><title>Output variables</title>
<para>
  The steeady state is available in <varname>ys_</varname>. Endogenous variables are ordered alphabeticaly as in <varname>lgy_</varname>.  
</para>
</refsect1>

<refsect1><title>Examples</title>
<para>
See <xref linkend='initval'/> and <xref linkend='endval'/>.
</para>
</refsect1>
</refentry>     

<refentry id="homotopy_setup">
  <refmeta>
    <refentrytitle>homotopy_setup</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>homotopy_setup</refname>
    <refpurpose>instructs <xref linkend="steady"/> to use homotopy methods</refpurpose>
  </refnamediv>
</refentry>

<refentry id="check">
  <refmeta>
    <refentrytitle>check</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>check</refname>
    <refpurpose>computes the eigenvalues of the (linearized) model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>check</command>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
Computes the eigenvalues of the model linearized around the values specified by the last <xref linkend='initval'/>, <xref linkend='endval'/> or <xref linkend='steady'/> statement. Generally, the eigenvalues are only meaningfull if the linearization is done around a steady state of the model. It is a device for local analysis in the neighborhood of this steady state.
</para>
<para>
A necessary condition for the uniqueness of a stable equilibrium in the neighborhood of the steady state is that there are as many eigenvalues larger than one in modulus as there are forward looking variables in the system. An additional rank condition requires that the square submatrix of the right Schur vectors corresponding to the forward looking variables (jumpers) and to the explosive eigenvalues must have full rank.
</para>
</refsect1>

<refsect1><title>Output variables</title>
<para>
<command>check</command> returns the eigenvalues in the global variable <varname>eigenvalues_</varname>.
</para>
</refsect1>
</refentry>

<refentry id="forecast">
  <refmeta>
    <refentrytitle>forecast</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>forecast</refname>
    <refpurpose>computes a simulation of a stochastic model from a given state</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>forecast</command>
      <arg>(<arg rep="repeat" choice="plain"><replaceable>OPTION</replaceable>,</arg>)</arg>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<itemizedlist spacing='compact'>
<listitem><para><command>periods</command> = INTEGER: number of periods of the forecast (default = 40)</para></listitem>
<listitem><para><command>conf_sig</command> = DOUBLE: level of significance for confidence interval (default = 0.90)</para></listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Description</title>
<para><command>forecast</command> computes a simulation of a stochastic model from an arbitrary initial point.</para>
<para>When the model also contains deterministic exogenous shocks, the simulation is computed conditionaly to the agents knowing the future values of the deterministic exogenous variables.</para>

<para><command>forecast</command> must be called after <xref linkend="stoch_simul"/>.</para>

<para> <command>forecast</command> plots the trajectory of endogenous variables. When a list of variable names follows the command, only those variables are ploted. A 90% confidence interval is ploted around the mean trajectory. Use option <command>conf_sig</command> to change the level of the confidence interval.</para>
</refsect1>

<refsect1><title>Output variables</title>
<para>The following variables are set in structure <varname>oo_</varname>:
<itemizedlist spacing="compact">
<listitem><para><varname>oo_.forecast.Mean.</varname><replaceable>VARIABLE NAME</replaceable>: mean forecast of endogenous variables</para></listitem>
<listitem><para><varname>oo_.forecast.HPDinf.</varname><replaceable>VARIABLE NAME</replaceable>: lower bound of a confidence interval around the forecast</para></listitem>
<listitem><para><varname>oo_.forecast.HPDsup.</varname><replaceable>VARIABLE NAME</replaceable>: upper bound of a confidence interval around the forecast</para></listitem>
<listitem><para><varname>oo_.forecast.Exogenous.</varname><replaceable>VARIABLE NAME</replaceable>: trajectory of the deterministic exogenous variables</para></listitem>
</itemizedlist>
</para>
</refsect1>


<refsect1><title>Example</title>
<informalexample>
  <programlisting>
varexo_det tau;
varexo e;

...

shocks;
var e; stderr 0.01;
var tau;
periods 1:9;
values -0.15;
end;

stoch_simul(irf=0);

forecast;
  </programlisting>
</informalexample>
</refsect1>
</refentry>

<refentry id="simul">
  <refmeta>
    <refentrytitle>simul</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>simul</refname>
    <refpurpose>simulates a deterministic model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>simul</command>
      <arg>
	(periods=<replaceable>INTEGER</replaceable>)
      </arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1><title>Description</title>
  <para>
    Triggers the computation of a deterministic simulation of the model for the number of periods set in the option <command>periods=</command>. <command>simul</command> uses a Newton method to solve simultaneously all the equations for every period (see Juillard, 1996).
  </para>
  </refsect1>
<refsect1><title>Output variables</title>
<para>
the simulated variables are available in global matrix <varname>y_</varname>. The variables are arranged row by row, in alphabetical order.
</para>
</refsect1>
</refentry>


<refentry id="stoch_simul">
  <refmeta>
    <refentrytitle>stoch_simul</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>stoch_simul</refname>
    <refpurpose>computes the solution and simulates the model</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>stoch_simul</command>
      <arg>(<arg rep="repeat" choice="plain"><replaceable>OPTION</replaceable>,</arg>)</arg>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Options</title>
<itemizedlist spacing='compact'>
<listitem><para><anchor id="ar" xreflabel="ar"/> <command>ar</command> = <replaceable>INTEGER</replaceable>:
Order of autocorrelation coefficients to compute and to print (default = 5)
n</para></listitem>
<listitem><para> <command>dr_algo = 0 | 1</command>: 
specifies the algorithm used for computing the quadratic approximation of the decision rules:
<itemizedlist spacing='compact'>
<listitem><para> 0: uses a <emphasis>pure</emphasis> perturbation approach as in Schmitt-Grohe and Uribe (2002) (default)
</para></listitem>
<listitem><para> 1: moves the point around which the Taylor expansion is computed toward the means of the distribution as in Collard and Juillard (2001)
</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><para> <command>drop</command> = <replaceable>INTEGER</replaceable>:
number of points dropped at the beginning of simulation before computing the summary statistics (default = 100)
</para></listitem>
<listitem><para> <command>hp_filter</command> = <replaceable>INTEGER</replaceable>:
 uses HP filter with lambda = <replaceable>INTEGER</replaceable> before computing moments (default: no filter)
</para></listitem>
<listitem><para> <command>hp_ngrid</command> = <replaceable>INTEGER</replaceable>:
number of points in the grid for the discreet Inverse Fast Fourier Transform used in the HP filter computation. It may be necessary to increase it for highly autocorrelated processes (default = 512) 
</para></listitem>
<listitem><para> <command>irf</command> = <replaceable>INTEGER</replaceable>:
 number of periods on which to compute the IRFs (default = 40). Setting IRF=0, suppresses the plotting of IRF's. 
</para></listitem>
<listitem><para><command>relative_irf</command> requests the computation of normalized IRFs in percentage of the standard error of each shock</para></listitem>
<listitem><para> <command>linear</command>:
 indicates that the original model is linear (put it rather in the MODEL command).
</para></listitem>
<listitem><para> <command>nocorr</command>: 
doesn't print the correlation matrix (printing them is the default)
</para></listitem>
<listitem><para> <command>nofunctions</command>:
 doesn't print the coefficients of the approximated solution (printing them is the default)
</para></listitem>
<listitem><para> <command>nomoments</command>: 
doesn't print moments of the endogenous variables (printing them is the default)</para></listitem>
<listitem><para> <command>noprint</command>: cancel any printing. Usefull for loops.</para></listitem>
<listitem><para> <command>order</command> = 1 | 2 :
order of Taylor approximation (default = 2)
</para></listitem>
<listitem><para> <command>periods</command> = <replaceable>INTEGER</replaceable>: specifies the number of periods to use in simulations. At order=1, no simulation is necessary to compute theoretical moments and IRFs. A number of periods larger than one triggers automatically option <command>simul</command> (default = 0).
</para></listitem>
<listitem><para> <command>qz_criterium</command> = <replaceable>INTEGER</replaceable> | <replaceable>DOUBLE</replaceable>:
value used to split stable from unstable eigenvalues in reordering the Generalized Schur decomposition used for solving 1st order problems (default 1.000001)
</para></listitem>
<listitem><para> <command>replic</command> = <replaceable>INTEGER</replaceable>: number of simulated series used to compute the IRFs (default = 1, if order = 1, and 50 otherwise)
</para></listitem>
<listitem><para> <command>simul</command>: 
computes a stochastic simulation of the model for the number of periods specified in the <command>periods</command> statement. Uses <xref linkend='initval'/> values, possibly recomputed by <xref linkend='steady'/>, as initial values for the simulation. The simulated endogenous variables are made available to the user in a vector for each variable and in the global matrix <varname>y_</varname>. The variables are ordered alphabeticaly in the <varname>y_</varname> matrix (default: no simulation)
</para></listitem>
<listitem><para> <command>simul_seed</command> = <replaceable>INTEGER</replaceable>|<replaceable>DOUBLE</replaceable>|<replaceable>(EXPRESSION)</replaceable>:
 specifies a seed for the random generator so as to obtain the same random sample at each run of the program. Otherwise a different sample is used for each run (default: seed not specified). Note that if you use an EXPRESSION rather than an INTEGER or a DOUBLE, the EXPRESSION must be in parenthesis.
</para></listitem>
<listitem><para> all <command>steady</command> options (see <xref linkend='steady'/>)</para></listitem>
</itemizedlist>
<para>
When a list of VARIABLE_NAMEs is specified, results are displayed only for these variables.
</para>
</refsect1>
<refsect1><title>Description</title>
<para>
<command>stoch_simul</command> computes a Taylor approximation of the decision and transition functions for the model, impulse response functions and various descriptive statistics (moments, variance decomposition, correlation and autocorrelation coefficients). For correlated shocks, the variance decomposition is computed as in the VAR literature through a Cholesky decomposition of the covariance matrix of the exogenous variables. When the shocks are correlated, the variance decomposition depends upon the order of the variables in the <xref linkend='varexo'/> command.
</para>

<para>The Taylor approximation is computed around the steady state (except whith option <command>dr_algo=1</command>). If you know how to compute the steady state for your model, you can provide a Matlab function doing the computation instead of using the nonlinear solver. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

<para>
Variance decomposition, correlation, autocorrelation are only displayed for variables with positive variance. Impulse response functions are only ploted for variables with response larger than 1e-10.
</para>
<para>
Currently, the IRF's are only ploted for 12 variables. Select the ones you want to see, if your model contains more than 12 endogenous variables.
</para>
<para>Currently, the HP filter is only available when computing theoretical moments, not for for moments of simulated variables.
</para>
<para>
The covariance matrix of the shocks is specified either with the <xref linkend='shocks'/> command or with the <xref linkend='Sigma_e'/> command.
</para>
</refsect1>

<refsect1><title>Decision rules</title>
<para>
The approximated solution of a model takes the form of a set of decision rules or transition equations expressing the current value of the endogenous variables of the model as function of the previous state of the model and shocks oberved at the beginning of the period.
</para>
<refsect2><title>First order approximation</title>
<blockquote><para>
y<subscript>t</subscript> = ys + A yh<subscript>t-1</subscript> + B u<subscript>t</subscript>
</para>
<para>
where ys is the steady state value of y and yh<subscript>t</subscript>=y<subscript>t</subscript>-ys.
</para>
</blockquote>
</refsect2>
<refsect2><title>Second order approximation</title>
<blockquote><para>
y<subscript>t</subscript> = ys + 0.5&Delta;<superscript>2</superscript> + A yh<subscript>t-1</subscript> + B u<subscript>t</subscript> + 0.5C(yh<subscript>t-1</subscript>&otimes;yh<subscript>t-1</subscript>) + 0.5D(u<subscript>t</subscript>&otimes;u<subscript>t</subscript>) + E(yh<subscript>t-1</subscript>&otimes;u<subscript>t</subscript>)
</para>
<para>
where ys is the steady state value of y, yh<subscript>t</subscript>=y<subscript>t</subscript>-ys, and &Delta;<superscript>2</superscript> is the shift effect of the variance of future shocks.
</para>
</blockquote>
</refsect2>
</refsect1>

<refsect1><title>Output variables</title>
<para>
<command>stoch_simul</command> sets several fields in global variable <varname>oo_</varname>. The descriptive statistics are theoretical moments when no simulation is requested and otherwise represent the moments of the simulated variables. 
<itemizedlist>
<listitem><para>the coefficients of the decision rules are stored in global structure<varname>dr_</varname>. Here is the correspondance with the symbols used in the above description of the decision rules:
<itemizedlist><title>Decision rule coefficients</title>

<listitem><para><varname>ys</varname>: <varname>dr_.ys</varname>. The vector rows correspond to variables in alphabetical order of the variable names.</para></listitem>
<listitem><para>&Delta;<superscript>2</superscript>: <varname>dr_.ghs2</varname>. The vector rows correspond to re-ordered variables (see below).</para></listitem>
<listitem><para><varname>A</varname>: <varname>dr_.ghx</varname>. The matrix rows correspond to re-ordered variables. The matrix columns correspond to state variables (see below).</para></listitem>
<listitem><para><varname>B</varname>: <varname>dr_.ghu</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to exogenous variables in alphabetical order.</para></listitem>
<listitem><para><varname>C</varname>: <varname>dr_.ghxx</varname>. The matrix rows correspond to re-ordered variables. The matrix columns correspond to the Kronecker product of the vector of state variables (see below).</para></listitem>
<listitem><para><varname>D</varname>: <varname>dr_.ghuu</varname>. The matrix rows correspond to re-ordered variables (see below). The matrix columns correspond to the Kronecker product of exogenous variables in alphabetical order.</para></listitem>
<listitem><para><varname>E</varname>: <varname>dr_.ghxu</varname>. The matrix rows correspond to re-ordered variables. The matrix columns correspond to the Kronecker product of the vector of state variables (see below) by the vector of exogenous variables in alphabetical order.</para></listitem>
</itemizedlist>
When reordered, the variables are stored in the following order: static variables, purely predetermined variables (variables that appear only at the current and lagged periods in the model), variables that are both predetermined and forward-looking (variables that appear at the current, future and lagged periods in the model), purely forward-looking variables (variables that appear only at the current and future periods in the model). In each category, the variables are arranged alphabetically.</para>
<para>
The state variables of the model are purely predetermined variables and variables that are both predetermined and forward-looking. They are ordered in that order. When there are lags on more than one period, the state variables are ordered first according to their lag: first variables from the previous period, then variables from two periods before and so on. Note also that when a variable appears in the model at a lag larger than one period, it is automatically included at all inferior lags.
</para>
</listitem>
<listitem><para>The mean of the endogenous variables is available in the vector <varname>oo_.mean</varname>. The variables are arranged in alphabetical order.
</para></listitem>
<listitem><para>The matrix of variance-covariance of the endogenous variables in the matrix <varname>oo_.var</varname>. The variables are arranged in alphabetical order.</para></listitem>
<listitem><para>The matrix of autocorrelation of the endogenous variables are made available in cell array <varname>oo_.autocorr</varname>. The element number of the matrix in the cell array corresponds to the order of autocorrelation. The option <varname>AR</varname> (default ar=5) specifies the number of autocorrelation matrices available.
</para></listitem>
<listitem>
<para>
  Simulated variables, when they have been computed, are available in Matlab
vectors with the same name as the endogenous variables.</para>
</listitem>
<listitem>
<para>
  Impulse responses, when they have been computed, are available in Matlab vectors witht the following naming convention <replaceable>VARIABLE_NAME</replaceable>_<replaceable>shock name</replaceable>.
</para>
<informalexample><para>
  <varname>gnp_ea</varname> contains the effect on <varname>gnp</varname> of a one standard deviation shock on <varname>ea</varname>.
</para>
</informalexample>
</listitem>
</itemizedlist>
</para>
</refsect1>

<refsect1><title>Example 1</title>
<programlisting>
shocks;
var e;
stderr 0.0348;
end;

stoch_simul;
</programlisting>
<para>
performs the simulation of the 2nd order approximation of a model with a single stochastic shock, e, with a standard error of 0.0348.
</para>
</refsect1>

<refsect1><title>Example 2</title>
<programlisting>
stoch_simul(linear,irf=60) y k;
</programlisting>
<para>
performs the simulation of a linear model and displays impulse response functions on 60 periods for variables <varname>y</varname> and <varname>k</varname>.
</para>
</refsect1>
</refentry>
</sect1>

<sect1><title>Estimation</title>
<para>
Provided that you have observations on some endogenous variables, it is possible to use Dynare to estimate some or all parameters. Both maximum likelihood and Bayesian techniques are available.
</para>

<para>
Note that in order to avoid stochastic singularity, you must have at least as many shocks or measurement errors in your model as you have observed variables. 
</para>
<itemizedlist>
<listitem><para><xref linkend='varobs'/></para></listitem>
<listitem><para><xref linkend='observation_trends'/></para></listitem>
<listitem><para><xref linkend='estimated_params'/></para></listitem>
<listitem><para><xref linkend='estimated_params_init'/></para></listitem>
<listitem><para><xref linkend='estimated_params_bounds'/></para></listitem>
<listitem><para><xref linkend='estimated_params_init'/></para></listitem>
<listitem><para><xref linkend='estimation'/></para></listitem>
<listitem><para><xref linkend='prior_analysis'/></para></listitem>
<listitem><para><xref linkend='posterior_analysis'/></para></listitem>
<listitem><para><xref linkend='unit_root_vars'/></para></listitem>
</itemizedlist>

<refentry id="varobs">
  <refmeta>
    <refentrytitle>varobs</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>varobs</refname>
    <refpurpose>lists the observed variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>varobs</command>
      <arg choice="plain" rep="repeat">
	<replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat">
	<replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>varobs</command> lists the name of observed endogenous variables for the estimation procedure. These variables must be available in the data file (see <xref linkend='estimation'/>).
</para>
</refsect1>

<refsect1><title>Example</title>
<para>
  <informalexample>
    <programlisting>
      varobs C y rr;
    </programlisting>
  </informalexample>
</para>
</refsect1>

</refentry>

<refentry id="observation_trends">
  <refmeta>
    <refentrytitle>observation_trends</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>observation_trends</refname>
    <refpurpose>specifies linear trends for observed variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>observation_trends;</command><sbr/>
      <arg choice="plain">
	<replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">
	(<replaceable>EXPRESSION</replaceable>);
      </arg><sbr/>
      <arg choice="plain">
	end;
      </arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>observation_trends</command> specifies trends for observed variables as functions of model parameters. In most cases, variables shouldn't be centered when <command>observation_trends</command> is used. 
</para>
</refsect1>

<refsect1><title>Example</title>
<para>
  <informalexample>
    <programlisting>
      observation_trends;
      Y (eta);
      P (mu/eta);
      end;
    </programlisting>
  </informalexample>
</para>
</refsect1>

</refentry>

<refentry id="estimated_params">
  <refmeta>
    <refentrytitle>estimated_params</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params</refname>
    <refpurpose>specifies the estimated parameters and their prior</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <para>Syntax I (maximum likelihood estimation)</para>
    <cmdsynopsis>
      <command>estimated_params;</command><sbr/>
      <group choice="req">
      <arg choice="plain">
	stderr <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">
	corr <replaceable>VARIABLE_NAME_1, VARIABLE_NAME_2</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>PARAMETER_NAME</replaceable>
	</arg>
      </group>
	<arg choice="plain">
	  <replaceable>, INITIAL_VALUE</replaceable>
	</arg>
	<arg choice="opt">
	  <replaceable>, LOWER_BOUND</replaceable>
	</arg>
	<arg choice="opt">
	  <replaceable>, UPPER_BOUND</replaceable>
	</arg>
	<arg choice="plain">;</arg><sbr/>
	<arg choice='plain'>...</arg><sbr/>
	  <arg choice="plain">end;</arg>
    </cmdsynopsis>
    <para>Syntax II (Bayesian estimation)</para>
    <cmdsynopsis>
      <command>estimated_params;</command><sbr/>
      <group choice="req">
      <arg choice="plain">
	stderr <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">
	corr <replaceable>VARIABLE_NAME_1, VARIABLE_NAME_2</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>PARAMETER_NAME</replaceable>
	</arg>
      </group>
      <arg choice="plain">
	<replaceable>, PRIOR_SHAPE</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>, PRIOR_MEAN</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>, PRIOR_STANDARD_ERROR</replaceable>
      </arg>
      <arg choice="opt">
	  <replaceable>, PRIOR_3RD_PARAMETER</replaceable>
      </arg>
      <arg choice="opt">
	<replaceable>, PRIOR_4TH_PARAMETER</replaceable>
      </arg>
      <arg choice="opt">
	<replaceable>, SCALE_PARAMETER</replaceable>
      </arg>
	<arg choice="plain">;</arg>
	<sbr/>
	<arg choice="plain">...</arg><sbr/>
	<arg choice="plain">end;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
  The <command>estimated_params;....end;</command> block lists all parameters to be estimated and specifies bounds and priors as necessary.
</para>
</refsect1>

<refsect1><title>Estimated parameter specification</title>
<para>
Each line corresponds to an estimated parameter and follows this syntax:
<itemizedlist spacing='compact'> 
  <listitem><para><command>stderr</command> is a keyword indicating that the standard error of the exogenous variable, <replaceable>VARIABLE_NAME</replaceable>, or of the observation error associated with endogenous observed variable, <replaceable>VARIABLE_NAME</replaceable>, is to be estimated</para></listitem>
  <listitem><para><command>corr</command> is a keyword indicating that the correlation between the exogenous variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, or the correlation of the observation errors associated with endogenous observed variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, is to be estimated</para></listitem>
  <listitem><para> <replaceable>PARAMETER_NAME</replaceable> is the name of a model parameter to be estimated</para></listitem>
<listitem><para> <replaceable>INITIAL_VALUE</replaceable> specifies a starting value for maximum likelihood estimation</para></listitem>
<listitem><para> <replaceable>LOWER_BOUND</replaceable> specifies a lower bound for the parameter value in maximum likelihood estimation</para></listitem>
<listitem><para> <replaceable>UPPER_BOUND</replaceable> specifies an upper bound for the parameter value in maximum likelihood estimation</para></listitem>
  <listitem><para> <replaceable>PRIOR_SHAPE</replaceable> is prior density among <command>beta_pdf</command>, <command>gamma_pdf</command>, <command>normal_pdf</command>, <command>inv_gamma_pdf</command>, <command>inv_gamma1_pdf</command>, <command>inv_gamma2_pdf</command>, <command>uniform_pdf</command></para></listitem>
  <listitem><para> <replaceable>PRIOR_MEAN</replaceable> is the mean of the prior distribution</para></listitem>
  <listitem><para> <replaceable>PRIOR_STANDARD_ERROR</replaceable> is the standard error of the prior distribution</para></listitem>
  <listitem><para> <replaceable>PRIOR_3RD_PARAMETER</replaceable> is a third parameter of the prior used for generalized beta distribution, generalized gamma and for the uniform distribution (default 0)</para></listitem>
  <listitem><para> <replaceable>PRIOR_4TH_PARAMETER</replaceable> is a fourth parameter of the prior used for generalized beta distribution, generalized gamma and for the uniform distribution (default 1)</para></listitem>
  <listitem><para> <replaceable>SCALE_PARAMETER</replaceable> is the scale parameter to be used for the jump distribution of the Metropolis-Hasting algorithm</para></listitem>
</itemizedlist>

<note><para> At minimum, one must specify the name of the parameter and an initial guess. That will trigger unconstrained maximum likelihood estimation.
</para></note>

<note><para> As one uses options more towards the end of the list, all previous options must be filled: if you want to specify <replaceable>jscale</replaceable>, you must specify <replaceable>prior_p3</replaceable> and <replaceable>prior_p4</replaceable>. Use default values, if these parameters don't apply. 
</para></note>
</para>
</refsect1>

<refsect1><title>Parameter transformation</title>
<para>
Sometimes, it is desirable to estimate a transformation of a parameter appearing in the model, rather than the parameter itself. It is of course possible to replace the original parameter by a function of the estimated parameter everywhere is the model, but it is often unpractical.
</para>

<para>
In such a case, it is possible to declare the parameter to be estimated in the <xref linkend="parameters"/> statement and to define the transformation at the top of the <xref linkend="model"/> section, as a Matlab expression. The first character of the line must be a pound  sign (#).
</para>
</refsect1>

<refsect1><title>Example</title>
<informalexample>
    <programlisting>
      parameters bet;

      model;
      # sig = 1/bet;
      c = sig*c(+1)*mpk;
      end;

      estimated_params;
      bet,normal_pdf,1,0.05;
      end;
    </programlisting>
  </informalexample>
</refsect1>



</refentry>

<refentry id="estimated_params_init">
  <refmeta>
    <refentrytitle>estimated_params_init</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params_init</refname>
    <refpurpose>specifies initial values for optimization</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimated_params_init;</command><sbr/>
      <group choice="req">
      <arg choice="plain">
	stderr <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">
	corr <replaceable>VARIABLE_NAME_1, VARIABLE_NAME_2</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>PARAMETER_NAME</replaceable>
	</arg>
      </group>
	<arg choice="plain">
	  <replaceable>, INITIAL_VALUE</replaceable>
	</arg> 
	<arg choice="plain">;</arg><sbr/>
	<arg choice='plain'>...</arg><sbr/>
	  <arg choice="plain">end;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
  The <command>estimated_params_init;....end;</command> block declares numerical initial values for the optimizer when these ones are different from the prior mean
</para>
</refsect1>

<refsect1><title>Estimated parameter initial value specification</title>
<para>
Each line corresponds to an estimated parameter and follows this syntax:
<itemizedlist spacing='compact'> 
  <listitem><para><command>stderr</command> is a keyword indicating that the standard error of the exogenous variable, <replaceable>VARIABLE_NAME</replaceable>, or of the observation error associated with endogenous observed variable, <replaceable>VARIABLE_NAME</replaceable>, is to be estimated</para></listitem>
  <listitem><para><command>corr</command> is a keyword indicating that the correlation between the exogenous variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, or the correlation of the observation errors associated with endogenous observed variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, is to be estimated</para></listitem>
  <listitem><para> <replaceable>PARAMETER_NAME</replaceable> is the name of a model parameter to be estimated</para></listitem>
<listitem><para> <replaceable>INITIAL_VALUE</replaceable> specifies a starting value for maximum likelihood estimation</para></listitem>
</itemizedlist>
</para>
</refsect1>

</refentry>

<refentry id="estimated_params_bounds">
  <refmeta>
    <refentrytitle>estimated_params_bounds</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimated_params_bounds</refname>
    <refpurpose>specifies lower and upper bounds for the estimated parameters</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimated_params_bounds;</command><sbr/>
      <group choice="req">
      <arg choice="plain">
	stderr <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">
	corr <replaceable>VARIABLE_NAME_1, VARIABLE_NAME_2</replaceable>
      </arg>
      <arg choice="plain">
	<replaceable>PARAMETER_NAME</replaceable>
	</arg>
      </group>
	<arg choice="plain">
	  <replaceable>, LOWER_BOUND</replaceable>
	</arg>
	<arg choice="plain">
	  <replaceable>, UPPER_BOUND</replaceable>
	</arg>
	<arg choice="plain">;</arg><sbr/>
	<arg choice='plain'>...</arg><sbr/>
	  <arg choice="plain">end;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
  The <command>estimated_params;....end;</command> block lists all parameter to be estimated and specifies bounds and priors when required.
</para>
</refsect1>

<refsect1><title>Estimated parameter specification</title>
<para>
Each line corresponds to an estimated parameter and follows this syntax:
<itemizedlist spacing='compact'> 
  <listitem><para><command>stderr</command> is a keyword indicating that the standard error of the exogenous variable, <replaceable>VARIABLE_NAME</replaceable>, or of the observation error associated with endogenous observed variable, <replaceable>VARIABLE_NAME</replaceable>, is to be estimated</para></listitem>
  <listitem><para><command>corr</command> is a keyword indicating that the correlation between the exogenous variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, or the correlation of the observation errors associated with endogenous observed variables, <replaceable>VARIABLE_NAME_1</replaceable> and <replaceable>VARIABLE_NAME_2</replaceable>, is to be estimated</para></listitem>
  <listitem><para> <replaceable>PARAMETER_NAME</replaceable> is the name of a model parameter to be estimated</para></listitem>
<listitem><para> <replaceable>LOWER_BOUND</replaceable> specifies a lower bound for the parameter value in maximum likelihood estimation</para></listitem>
<listitem><para> <replaceable>UPPER_BOUND</replaceable> specifies an upper bound for the parameter value in maximum likelihood estimation</para></listitem>
</itemizedlist>
</para>
</refsect1>
</refentry>

<refentry id="estimation">
 <refmeta>
    <refentrytitle>estimation</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>estimation</refname>
    <refpurpose>computes estimation.</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>estimation</command>
      <arg>(OPTIONS)</arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>OPTIONS</title>
<itemizedlist spacing='compact'>
<listitem><para> <command>datafile</command> =
	  <replaceable>FILENAME</replaceable>: the datafile (a .m file, a .mat file or a .xls file)</para></listitem>
<listitem><para><command>xls_sheet</command> = <replaceable>NAME</replaceable>: the name of the sheet with the data in an Excel file</para></listitem>
<listitem><para><command>xls_range</command> = <replaceable>RANGE</replaceable>: the range with the data in an Excel file</para></listitem>
<listitem><para><command>nobs</command> = <replaceable>INTEGER</replaceable>: the number of observations to be used (default: all observations in the file)</para>
<para><command>nobs</command> = ([<replaceable>INTEGER_1</replaceable>:<replaceable>INTEGER_2</replaceable>]): runs a recursive estimation and forecast for samples of size ranging of <varname>INTEGER_1</varname> to <varname>INTEGER_2</varname>. Option <varname>FORECAST</varname> must also be specified.</para> 
</listitem>
<listitem><para> <command>first_obs</command> = <replaceable>INTEGER</replaceable>: the number of the first observation to be used (default = 1)</para></listitem>
<listitem><para> <command>prefilter</command> = 1: the estimation procedure demeans the data (default=0, no prefiltering)</para></listitem>
<listitem><para> <command>presample</command> = <replaceable>INTEGER</replaceable>: the number of observations to be skipped before evaluating the likelihood (default = 0)</para></listitem>
<listitem><para> <command>loglinear</command>: computes a log--linear approximation of the model instead of a linear (default) approximation. The data must correspond to the definition of the variables used in the modelx.</para></listitem>
<listitem><para> <command>nograph</command>: no graphs should be plotted</para></listitem>
<listitem><para> <command>lik_init</command>: <replaceable>INTEGER</replaceable>: type of initialization of Kalman filter.
<itemizedlist spacing='compact'>
  <listitem><para>1 (default): for stationary models, the initial matrix of variance of the error of forecast is set equal to the unconditional variance of the state variables.</para></listitem>
  <listitem><para>2: for nonstationary models: a wide prior is used with an initial matrix of variance of the error of forecast diagonal with 10 on the diagonal.</para></listitem>
</itemizedlist>
</para></listitem>
<listitem><anchor id="conf_sig" xreflabel="conf_sig"/><para><command>conf_sig</command> = <replaceable>{INTEGER | DOUBLE}</replaceable>: the level for the confidence intervals reported in the results (default = 0.90)</para></listitem>
<listitem><anchor id="mh_replic" xreflabel="mh_replic"/><para> <command>mh_replic</command> = <replaceable>INTEGER</replaceable>: number of replication for Metropolis Hasting algorithm. For the time being, mh_replic should be larger than 1200 (default = 20000.)</para></listitem>
<listitem><para> <command>mh_nblocks</command> = <replaceable>INTEGER</replaceable>: number of paralletl chains for Metropolis Hasting algorithm (default = 2).</para></listitem>
<listitem><para> <command>mh_drop</command> = <replaceable>DOUBLE</replaceable>: the fraction of initially generated parameter vectors to be dropped before using posterior simulations (default = 0.5)</para></listitem>
<listitem><para> <command>mh_jscale</command> = <replaceable>DOUBLE</replaceable>: the scale to be used for the jumping distribution in MH algorithm. The default value is rarely satisfactory. This option must be tune to obtain, ideally, an accpetation rate of 25% in the Metropolis-Hastings algorithm (default = 0.2).</para></listitem>
<listitem><para><command>mh_init_scale</command>=<replaceable>DOUBLE</replaceable>: the scale to be used for drawing the initial value of the Metropolis-Hastings chain (default=2*mh_scale).</para>
</listitem>
<listitem><anchor id="mh_recover" xreflabel="mh_recover"/><para><command>mh_recover</command> attempts to recover a Metropolis simulation that crashed prematurely. Shouldn't be used together with <link linkend="load_mh_file">load_mh_file</link></para></listitem>
<listitem><para><command>mode_file</command>=<replaceable>FILENAME</replaceable>: name of the file containing previous value for the mode. When computing the mode, Dynare stores the mode (<varname>xparam1</varname>) and the hessian (<varname>hh</varname>) in a file called <filename><replaceable>MODEL NAME</replaceable>_mode</filename>.</para></listitem>
<listitem><para><command>mode_compute</command>=<replaceable>INTEGER</replaceable>: specifies the optimizer for the mode computation.
<itemizedlist spacing='compact'>
  <listitem><para>0: the mode isn't computed. mode_file must be specified</para></listitem>
  <listitem><para>1: uses Matlab <command>fmincon</command>.</para></listitem>
  <listitem><para>2: uses Lester Ingber's Adaptive Simulated Annealing.</para></listitem>
  <listitem><para>3: uses Matlab <command>fminunc</command>.</para></listitem>
  <listitem><para>4 (default): uses Chris Sim's <command>csminwel</command>.</para></listitem>
</itemizedlist></para></listitem>
<listitem><para><command>mode_check</command>: when <command>mode_check</command> is set, Dynare plots the posterior density for values around the computed mode for each estimated parameter in turn. This is helpful to diagnose problems with the optimizer.</para></listitem>
<listitem><para><command>prior_trunc</command>=<replaceable>DOUBLE</replaceable>: probability of extreme values of the prior density that is ignored when computing bounds for the parameters (default=1e-32).</para></listitem>
<listitem><anchor id="load_mh_file" xreflabel="load_mh_file"/><para><command>load_mh_file</command>: when <command>load_mh_file</command> is declared, Dynare adds to previous Metropolis-Hastings simulations instead of starting from scratch. Shouldn't be used together with <link linkend="mh_recover">mh_recover</link>.</para></listitem>
<listitem><para><command>optim</command>=(<replaceable>fmincon options</replaceable>): can be used to set options for fmincon, the optimizing function of Matlab Optimizaiton toolbox. Use Matlab syntax for these options</para>
<para> (default: ('display','iter','LargeScale','off','MaxFunEvals',100000,'TolFun',1e-8,'TolX',1e-6))</para></listitem>
<listitem>
  <para>
    <command>nodiagnostic</command>: doesn't compute the convergence diagnostics for Metropolis (default: diagnostics are computed and displayed).
  </para>
</listitem>
<listitem><para><anchor id="bayesian_irf" xreflabel="bayesian_irf"/><command>bayesian_irf</command> triggers the computation of the posterior distribution of IRFs. The length of the IRFs are controlled by the <command>irf</command> option</para></listitem>
<listitem><para><anchor id="moments_varendo" xreflabel="moments_varendo"/><command>moments_varendo</command> triggers the computation of the posterior distribution of the theoretical moments of the endogenous variables</para></listitem>
<listitem><para><anchor id="filtered_vars" xreflabel="filtered_vars"/><command>filtered_vars</command> triggers the computation of the posterior distribution of filtered endogenous variables and shocks</para></listitem>
<listitem><anchor id="smoother" xreflabel="smoother"/><para><command>smoother</command> triggers the computation of the posterior distribution of smoothered endogenous variables and shocks</para></listitem>
<listitem><para><anchor id="forecast_opt" xreflabel="forecast"/><command>forecast = </command><replaceable>INTEGER</replaceable> computes the posterior distribution of a forecast on <replaceable>INTEGER</replaceable> periods after the end of the sample used in estimation</para></listitem>
<listitem><para><command>tex</command> requests the printing of results and graphs in TeX tables and graphics that can be later directly included in Latex files (not yet implemented)</para></listitem>
<listitem><para>All options for <xref linkend="stoch_simul"/></para></listitem>
</itemizedlist>

<note><para> If no <command>mh_jscale</command> parameter is used in estimated_params, the procedure uses <command>mh_jscale</command> for all parameters. If <command>mh_jscale</command> option isn't set, the procedure uses 0.2 for all parameters.
</para></note>
</refsect1>

<refsect1><title>Results</title>
<itemizedlist spacing='compact'>
<listitem><para> results from posterior optimization (also for maximum likelihood)</para></listitem>
<listitem><para> marginal log density</para></listitem>
<listitem><para> mean and shortest confidence interval from posterior simulation</para></listitem>
<listitem><para>Metropolis-Hastings convergence graphs that still need to be documented</para></listitem>
<listitem><para> graphs with prior, posterior and mode</para></listitem>
<listitem><para> graphs of smoothed shocks, smoothed observation errors, smoothed and historical variables</para></listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Output</title>
<para>After running <command>estimation</command>, the parameters and the variance matrix of the shocks are set to the mode for maximum likelihood estimation or posterior mode computation without Metropolis iterations.
</para>
<para>After <command>estimation</command> with Metropolis iterations (option <command>mh_replic</command> > 0 or option <command>load_mh_file</command> set) the parameters and the variance matrix of the shocks are set to the posterior mean.</para>

<para>Depending on the options, <command>estimation</command> stores results in the following fields of structure <varname>oo_</varname>:
<table orient="land"><title>Content of <varname>oo_</varname></title><tgroup cols='6'>
<thead>
<row><entry>Field 1</entry><entry>Field 2</entry><entry>Field 3</entry><entry>Field 4</entry><entry>Field 5</entry><entry>Required options</entry></row>
</thead>
<tbody>
<row><entry><varname>Forecast</varname></entry><entry>See <xref linkend="ForecastsMoments"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><xref linkend="forecast_opt"/></entry></row>
<row><entry morerows='1'><varname>MarginalDensity</varname></entry><entry><varname>LaplaceApproximation</varname></entry><entry/><entry></entry><entry></entry><entry>Always provided</entry></row>
<row><entry><varname>ModifiedHarmonicMean</varname></entry><entry></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>PosteriorFilteredVariables</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="filtered_vars">filtered_vars</link></para></entry></row>
<row><entry><varname>PosteriorIRF</varname></entry><entry><varname>Dsge</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><para>IRF name: name of endogenous variable '_' name of shock</para></entry><entry></entry><entry><link linkend="bayesian_irf">bayesian_irf</link></entry></row>
<row><entry><varname>PosteriorSmoothedObservationErrors</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorSmoothedShocks</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorSmoothedVariables</varname></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><xref linkend="smoother"/></para></entry></row>
<row><entry><varname>PosteriorTheoreticalMoments</varname></entry><entry>See <xref linkend="TheoreticalMoments"/></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry>See <xref linkend="MomentsNames"/></entry><entry><replaceable>Variable name</replaceable></entry><entry><link linkend="moments_varendo">moments_varendo</link></entry></row>
<row><entry><varname>posterior_density</varname></entry><entry><replaceable>Parameter name</replaceable></entry><entry></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>posterior_hpdinf</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>posterior_hpdsup</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>posterior_mean</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>posterior_mode</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
<row><entry><varname>posterior_std</varname></entry><entry>See <xref linkend="EstimatedObjects"/></entry><entry><replaceable>Variable name</replaceable></entry><entry></entry><entry></entry><entry><para><link linkend="mh_replic">mh_replic</link>&gt; 0 or <link linkend="load_mh_file">load_mh_file</link></para></entry></row>
</tbody>
</tgroup>
</table>
</para>

<para><anchor id="ForecastsMoments" xreflabel="Moments of forecasts"/>
<table><title>Moments of forecasts</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>HPDinf</varname></entry><entry>Lower bound of a 90% HPD interval<footnote id="see_conf_sig"><para>See option <link linkend="conf_sig">conf_sig</link> to change the size of the HPD interval</para></footnote> of forecast  due to parameter uncertainty</entry></row> 
<row><entry><varname>HPDsup</varname></entry><entry>Lower bound of a 90% HPD interval <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty</entry></row> 
<row><entry><varname>HPDTotalinf</varname></entry><entry>Lower bound of a 90% HPD interval of forecast <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty and future shocks</entry></row> 
<row><entry><varname>HPDTotalsup</varname></entry><entry>Lower bound of a 90% HPD interval <footnoteref linkend="see_conf_sig"/> due to parameter uncertainty and future shocks</entry></row>
<row><entry><varname>Mean</varname></entry><entry>Mean of the posterior distribution of forecasts</entry></row> 
<row><entry><varname>Median</varname></entry><entry>Median of the posterior distribution of forecasts</entry></row>  
<row><entry><varname>Std</varname></entry> <entry>Standard deviation of the posterior distribution of forecasts</entry></row> 
</tbody>
</tgroup>
</table>
</para>
<para><anchor id="MomentsNames" xreflabel="Moments Names"/>
<table><title>Moments Names</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>HPDinf</varname></entry><entry>Lower bound of a 90% HPD interval<footnote id="see_conf_sig1"><para>See option <link linkend="conf_sig">conf_sig</link> to change the size of the HPD interval</para></footnote></entry></row> 
<row><entry><varname>HPDsup</varname></entry><entry>Upper bound of a 90% HPD interval <footnoteref linkend="see_conf_sig1"/> </entry></row> 
<row><entry><varname>Mean</varname></entry><entry>Mean of the posterior distribution</entry></row> 
<row><entry><varname>Median</varname></entry><entry>Median of the posterior distribution</entry></row>  
<row><entry><varname>Std</varname></entry> <entry>Standard deviation of the posterior distribution</entry></row> 
</tbody>
</tgroup>
</table>
</para>
<para><anchor id="TheoreticalMoments" xreflabel="Theoretical Moments"/>
<table><title>Theoretical Moments</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>Autocorrelation</varname></entry><entry>Autocorrelation of endogenous variables<footnote><para>The autocorrlation coefficients are computed for the number of periods specified in option <xref linkend="ar"/>.</para></footnote></entry></row>
<row><entry><varname>Correlation</varname></entry><entry>Correlation between two endogenous variables</entry></row>
<row><entry><varname>Decomp</varname></entry><entry>Decomposition of variance<footnote><para>When the shocks are correlated, it is the decomposition of orthogonalized shocks via Cholesky decompostion according to the order of declaration of shocks (see <xref linkend="varexo"/>).</para></footnote> </entry></row>
<row><entry><varname>Expectation</varname></entry><entry>Expectation of endogenous variables</entry></row>
<row><entry><varname>Variance</varname></entry><entry>(co-)variance of endogenous variables</entry></row>
</tbody>
</tgroup>
</table>
</para>

<para><anchor id="EstimatedObjects" xreflabel="Estimated Objects"/>
<table><title>Estimated objects</title>
<tgroup cols='2'>
<thead>
<row><entry>Field name</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><varname>measurement_errors_corr</varname></entry><entry>Correlation between two measurement errors</entry></row>
<row><entry><varname>measurement_errors_std</varname></entry><entry>Standard deviation of measurement errors</entry></row>
<row><entry><varname>parameters</varname></entry><entry>Parameters</entry></row>
<row><entry><varname>shocks_corr</varname></entry><entry>Correlation between two structural shocks</entry></row>
<row><entry><varname>shocks_std</varname></entry><entry>Standard deviation of structural shocks</entry></row>
</tbody>
</tgroup>
</table>
</para>

<refsect2><title>Examples</title>
<para>
<informalexample>
<programlisting>
oo_.posterior_mode.parameters.alp
oo_.posterior_mean.shocks_std.ex
oo_.posterior_hpdsup.measurement_errors_corr.gdp_conso
</programlisting>
</informalexample>
</para>
</refsect2>

</refsect1>

<refsect1><title>Note on steady state computation</title>
<para>If you know how to compute the steady state for your model, you can provide a Matlab function doing the computation instead of using <command>steady</command>. The function should be called with the name of the <filename class="extension">.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>
</refsect1>
</refentry>

<refentry id="prior_analysis">
  <refmeta>
    <refentrytitle>prior_analysis</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>prior_analysis</refname>
    <refpurpose>Prior distribution analysis</refpurpose>
  </refnamediv>
</refentry>

<refentry id="posterior_analysis">
  <refmeta>
    <refentrytitle>posterior_analysis</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>posterior_analysis</refname>
    <refpurpose>Posterior distribution analysis</refpurpose>
  </refnamediv>
</refentry>

<refentry id="unit_root_vars">
  <refmeta>
    <refentrytitle>unit_root_vars</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>unit_root_vars</refname>
    <refpurpose>declares unit-root variables for estimation</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>unit_root_vars</command>
      <arg choice="plain">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>unit_root_vars</command> is used to declare unit-root variables of a model so that a diffuse prior can be used in the initialization of the Kalman filter for these variables only. For stationary variables, the unconditional covariance matrix of these variables is used for initialization. The algorithm to compute a true diffuse prior is taken from Durbin and Koopman (2001, 2003).
</para>

<para>When <command>unit_root_vars</command> is used the <command>lik_init</command> option of <xref linkend="estimation"/> has no effect.
</para>

<para>When there are nonstationary variables in a model, there is no unique deterministic steady state. The user must supply a Matlab function that computes the steady state values of the stationary variables in the model and returns dummy values for the nonstationary ones. The function should be called with the name of the <filename>.mod</filename> file followed by <filename>_steadystate</filename>. See <filename>fs2000a_steadystate.m</filename> in <filename>examples/fs2000</filename> directory.
</para>

<para>Note that the nonstationary variables in the model must be integrated processes(their first difference or k-difference must be stationary).</para>
</refsect1>
</refentry>
</sect1>

<sect1><title>Optimal policy</title>
<para>Dynare has tools to compute optimal policies for quadratic objectives. You can either solve for optimal policy under commitment with <command>planner_objective</command> or for optimal simple rule with <xref linkend='osr'/>.
</para>

<itemizedlist>
<listitem><para><xref linkend='optim_weights'/></para></listitem>
<listitem><para><xref linkend='osr'/></para></listitem>
<listitem><para><xref linkend='osr_params'/></para></listitem>
<listitem><para><xref linkend='planner_objective'/></para></listitem>
<listitem><para><xref linkend='ramsey_policy'/></para></listitem>
</itemizedlist>

<refentry id="optim_weights">
  <refmeta>
    <refentrytitle>optim_weights</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>optim_weights</refname>
    <refpurpose>specifies quadratic objectives for optimal policy problems</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>optim_weights;</command><sbr/>
	<group choice="plain">
	  <arg choice="plain">
	    <synopfragmentref linkend="var_st1">VARIANCE STATEMENT</synopfragmentref>
	  </arg>
	  <arg choice="plain">
	    <synopfragmentref linkend="covar_st1">COVARIANCE STATEMENT</synopfragmentref>
	  </arg>
	  <arg choice="plain">
	    <synopfragmentref linkend="stderr_st1">STANDARD ERROR STATEMENT</synopfragmentref>
	  </arg>
	</group>
      <arg choice ="plain">end;</arg>
      <synopfragment id="var_st1">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
      <synopfragment id="covar_st1">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable> , <replaceable>VARIABLE_NAME</replaceable> = <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
      <synopfragment id="stderr_st1">
	<arg choice="plain">
	  var <replaceable>VARIABLE_NAME</replaceable>; stderr <replaceable>EXPRESSION</replaceable>;
	</arg>
      </synopfragment>
    </cmdsynopsis>
  </refsynopsisdiv>
<refsect1><title>Description</title>
<para>
<command>optim_weights</command> secifies the nonzero elements of the quadratic weight matrices for the objectives in <xref linkend='osr'/>
</para>
</refsect1>
</refentry>

<refentry id="osr">
  <refmeta>
    <refentrytitle>osr</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>osr</refname>
    <refpurpose>computes optimal simple policy rules</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>osr</command>
      <arg>(<arg rep="repeat" choice="plain"><replaceable>OPTION</replaceable>,</arg>)</arg>
      <arg choice="plain"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>VARIABLE_NAME</replaceable></arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>OPTIONS</title>
<itemizedlist spacing='compact'>
<listitem><para>All options for <xref linkend="stoch_simul"/></para></listitem>
</itemizedlist>
</refsect1>

<refsect1><title>Description</title>
<para>
<command>osr</command> computes optimal simple policy rules for linear--quadratic problems of the form
</para>
<blockquote><para>
max<subscript>&gamma;</subscript> E(y'<subscript>t</subscript>Wy<subscript>t</subscript>)
</para>
<para>s.t.</para>
<para>
  A<subscript>1</subscript>E<subscript>t</subscript>(y<subscript>t+1</subscript>)+A<subscript>2</subscript>y<subscript>t</subscript>+A<subscript>3</subscript>y<subscript>t-1</subscript>+Ce<subscript>t</subscript>=0
</para>
</blockquote>
<para>with</para>
<itemizedlist>
<listitem><para>&gamma;: parameters to be optimized. They must be elements of matrices A<subscript>1</subscript>, A<subscript>2</subscript>, A<subscript>3</subscript>.</para></listitem>
<listitem><para>y: endogenous variables</para></listitem>
<listitem><para>e: exogenous stochastic shocks</para></listitem>
</itemizedlist>
<para>The parameters to be optimized must be listed with <xref linkend='osr_params'/>.
</para>
<para>The quadratic objectives must be listed with <xref linkend='optim_weights'/>.
</para>
<para>
This problem is solved using a numerical optimizer.
</para>
</refsect1>
</refentry>

<refentry id="osr_params">
  <refmeta>
    <refentrytitle>osr_params</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>osr_params</refname>
    <refpurpose>declares the parameters to be optimized for optimal simple rules</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>osr_params</command>
      <arg choice="plain"><replaceable>PARAMETER_NAME</replaceable></arg>
      <arg rep="repeat"><replaceable>PARAMETER_NAME</replaceable></arg>
      <arg choice='plain'>;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>


<refsect1><title>Description</title>
<para>
<command>osr_params</command> declares parameters to be optimized  by <xref linkend='osr'/>.
</para>
</refsect1>
</refentry>

<refentry id="planner_objective">
  <refmeta>
    <refentrytitle>planner_objective</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>planner_objective</refname>
    <refpurpose>declares the policy maker objective, for use with <xref linkend="ramsey_policy"/></refpurpose>
  </refnamediv>
</refentry>

<refentry id="ramsey_policy">
  <refmeta>
    <refentrytitle>ramsey_policy</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>ramsey_policy</refname>
    <refpurpose>computes the first order approximation of the policy that maximizes the policy maker objective function (see <xref linkend="planner_objective"/>) submitted to the constraints provided by the equilibrium path of the economy</refpurpose>
  </refnamediv>
</refentry>

</sect1>

<sect1><title>Sensitivity analysis</title>

<refentry id="dynare_sensitivity">
  <refmeta>
    <refentrytitle>dynare_sensitivity</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynare_sensitivity</refname>
    <refpurpose>interface to the global sensitivity analysis (GSA) toolbox developed by the Joint Research Center of the European Commission</refpurpose>
  </refnamediv>
</refentry>

</sect1>

<sect1><title>Displaying and saving results</title>
<para>
Dynare has comments to plot the results of a simulation and to save the results.
</para>
<itemizedlist>
<listitem><para><xref linkend='rplot'/></para></listitem>
<listitem><para><xref linkend='dynatype'/></para></listitem>
<listitem><para><xref linkend='dynasave'/></para></listitem>
</itemizedlist>

<refentry id="rplot">
  <refmeta>
    <refentrytitle>rplot</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>rplot</refname>
    <refpurpose>plot variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>rplot</command>
      <arg choice="plain">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>
<refsect1><title>Description</title>
<para>
Plots one or several variables
</para>
</refsect1>
</refentry>

<refentry id="dynatype">
  <refmeta>
    <refentrytitle>dynatype</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynatype</refname>
    <refpurpose>print simulated variables</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynatype</command>
      <arg>
      (<replaceable>FILENAME</replaceable>)
      </arg>
      <arg choice="plain">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynatype</command> prints the listed variables in a text file named <replaceable>FILENAME</replaceable>. If no <replaceable>VARIABLE_NAME</replaceable> are listed, all endogenous variables are printed.
</para>
</refsect1>

</refentry>

<refentry id="dynasave">
  <refmeta>
    <refentrytitle>dynasave</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>dynasave</refname>
    <refpurpose>save simulated variables in a binary file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>dynasave</command>
      <arg>
      (<replaceable>FILENAME</replaceable>)
      </arg>
      <arg choice="plain">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg rep="repeat">
      <replaceable>VARIABLE_NAME</replaceable>
      </arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

<refsect1><title>Description</title>
<para>
<command>dynasave</command> saves the listed variables in a binary file named <replaceable>FILENAME</replaceable>. If no <replaceable>VARIABLE_NAME</replaceable> are listed, all endogenous variables are saved.
</para>
<para>
In Matlab, variables saved with the <command>dynasave</command> command can be retrieved by the Matlab command <command>load -mat <replaceable>FILENAME</replaceable></command>.
</para>
</refsect1>
</refentry>
</sect1>

<sect1 id="macrolanguage"><title>Macro-processing language</title>
<para>It is possible to use "macro" commands in the <filename class="extension">.mod</filename> file for doing the following tasks: source file inclusion, replicating blocks of equations through loops, conditional inclusion of code...</para>

<para>Technically, this macro language is totally independent of the basic Dynare language, and is processed by a separate component of the Dynare pre-processor. The macro processor transforms a <filename class="extension">.mod</filename> file with macros into a <filename class="extension">.mod</filename> file without macros (doing expansions/inclusions), and then feeds it to the Dynare parser.
</para>
<itemizedlist>
<listitem><para><xref linkend='include'/></para></listitem>
<listitem><para><xref linkend='define'/></para></listitem>
<listitem><para><xref linkend='if_else_endif'/></para></listitem>
<listitem><para><xref linkend='for_endfor'/></para></listitem>
<listitem><para><xref linkend='echo'/></para></listitem>
<listitem><para><xref linkend='error'/></para></listitem>
</itemizedlist>

<refentry id="include">
  <refmeta>
    <refentrytitle>@#include</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#include</refname>
    <refpurpose>includes another file</refpurpose>
  </refnamediv>
</refentry>

<refentry id="define">
  <refmeta>
    <refentrytitle>@#define</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#define</refname>
    <refpurpose>defines a macro-variable</refpurpose>
  </refnamediv>
</refentry>

<refentry id="if_else_endif">
  <refmeta>
    <refentrytitle>@#if ... @#else ... @#endif</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#if ... @#else ... @#endif</refname>
    <refpurpose>conditional inclusion of some part of the <filename class="extension">.mod</filename> file</refpurpose>
  </refnamediv>
</refentry>

<refentry id="for_endfor">
  <refmeta>
    <refentrytitle>@#for ... @#endfor</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#for ... @#endfor</refname>
    <refpurpose>loop for replications of portions of the <filename class="extension">.mod</filename> file</refpurpose>
  </refnamediv>
</refentry>

<refentry id="echo">
  <refmeta>
    <refentrytitle>@#echo</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#echo</refname>
    <refpurpose>asks the preprocessor to display some message on standard output</refpurpose>
  </refnamediv>
</refentry>

<refentry id="error">
  <refmeta>
    <refentrytitle>@#error</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>@#error</refname>
    <refpurpose>asks the preprocessor to display some error message on standard output and to abort</refpurpose>
  </refnamediv>
</refentry>

</sect1>

<sect1><title>Misc commands</title>

<itemizedlist>
  <listitem><para><xref linkend="save_params_and_steady_state"/></para></listitem>
  <listitem><para><xref linkend="load_params_and_steady_state"/></para></listitem>
  <listitem><para><xref linkend="bvar_density"/></para></listitem>
  <listitem><para><xref linkend="bvar_forecast"/></para></listitem>
</itemizedlist>

<refentry id="save_params_and_steady_state">
  <refmeta>
    <refentrytitle>save_params_and_steady_state</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>save_params_and_steady_state</refname>
    <refpurpose>saves the values of the parameters and of the computed steady-state in a file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>save_params_and_steady_state</command>
      <arg choice="plain"><replaceable>FILENAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>
    <para>For all parameters, endogenous and exogenous variables, stores
      their value in a file, using a simple name/value associative array.</para>
    <itemizedlist>
      <listitem><para>for parameters, the value is taken from the last parameter
          initialization</para></listitem>
      <listitem><para>for exogenous, the value is taken from the last initval block</para></listitem>
      <listitem><para>for endogenous, the value is taken from the last steady state computation
          (or, if no steady state has been computed, from the last initval block)</para></listitem>
    </itemizedlist>
    <para>Note that no variable type is stored in the file, so that the values
      can be reloaded (with <xref linkend="load_params_and_steady_state"/>) in a setup where
      the variable types are different.</para>
    <para>The typical usage of this function is to compute the steady-state of a
      model by calibrating the steady-state value of some endogenous variables (which implies that some parameters must be endogeneized
      during the steady-state computation).</para>
    <para>You would then write a first .mod file which computes the steady-state and saves the result of the
      computation at the end of the file, using <command>save_params_and_steady_state</command>.</para>
    <para>In a second file designed to perform the actual simulations, you would use <xref linkend="load_params_and_steady_state"/> just after
      your variable declarations, in order to load the steady-state previously computed (including the parameters which had been
      endogeneized during the steady-state computation).</para>
    <para>The need for two separate .mod files arises from the fact that the variable declarations differ between the files for
      steady-state calibration and for simulation (the set of endogenous and parameters differ between the two); this leads
      to different <xref linkend="var"/> and <xref linkend="parameters"/> statements.</para>
    <para>Also note that you can take advantage of the <xref linkend="include"/> directive to share the model equations between the two files.</para>
  </refsect1>
</refentry>

<refentry id="load_params_and_steady_state">
  <refmeta>
    <refentrytitle>load_params_and_steady_state</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>load_params_and_steady_state</refname>
    <refpurpose>loads the values of the parameters and of the steady-state from a file</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>load_params_and_steady_state</command>
      <arg choice="plain"><replaceable>FILENAME</replaceable></arg>
      <arg choice="plain">;</arg>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
    <title>Description</title>
    <para>For all parameters, endogenous and exogenous variables, loads
      their value from a file created with save_params_and_steady_state.</para>
    <itemizedlist>
      <listitem><para>for parameters, their value will be initialized as if they
          had been calibrated in the .mod file</para></listitem>
      <listitem><para>for endogenous and exogenous, their value will be initialized
          as they would have been from an initval block</para></listitem>
    </itemizedlist>
    <para>This function is used in conjunction with <xref linkend="save_params_and_steady_state"/>;
      see the documentation of that function for more information.</para>
  </refsect1>
</refentry>

<refentry id="bvar_density">
  <refmeta>
    <refentrytitle>bvar_density</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>bvar_density</refname>
    <refpurpose>computes the marginal density of an estimated BVAR model, using Minnesota priors</refpurpose>
  </refnamediv>
</refentry>

<refentry id="bvar_forecast">
  <refmeta>
    <refentrytitle>bvar_forecast</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>bvar_forecast</refname>
    <refpurpose>computes in-sample or out-sample forecasts for an estimated BVAR model, using Minnesota priors</refpurpose>
  </refnamediv>
</refentry>

</sect1>

</chapter>

<chapter><title>Examples</title>
<para>
Fabrice Collard (GREMAQ, University of Toulouse) has written a guide to stochastic simulations with Dynare entitled "Dynare in Practice" which is in <filename>guide.pdf</filename>.
</para>
</chapter>

<bibliography>
<biblioentry>
  <biblioset relation="article">
    <author>
      <surname> Boucekkine</surname>
      <firstname> Raouf</firstname>
    </author>
    <pubdate>1995</pubdate>
    <title>An alternative methodology for solving nonlinear forward-looking models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>19</volumenum>
    <pagenums>711-734</pagenums>
  </biblioset>
</biblioentry>
<biblioentry>
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Collard</surname>
	<firstname>Fabrice</firstname>
      </author>
      <author>
	<surname>Juillard</surname>
	<firstname>Michel</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>Accuracy of stochastic perturbation methods: The case of asset pricing models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>25</volumenum>
    <pagenums>979-999</pagenums>
  </biblioset>
</biblioentry>

<biblioentry> 
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Collard</surname>
	<firstname>Fabrice</firstname>
      </author>
      <author>
	<surname>Juillard</surname>
	<firstname>Michel</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>A Higher-Order Taylor Expansion Approach to Simulation of Stochastic Forward-Looking Models with an Application to a Non-Linear Phillips Curve</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Computational Economics</title>
    <volumenum>17</volumenum>
    <pagenums>125-139</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>
  <biblioset relation="book">
    <authorgroup>
      <author>
	<surname>Durbin</surname>
	<firstname>J.</firstname>
      </author>
      <author>
	<surname>Koopman</surname>
	<firstname>S.J.</firstname>
      </author>
    </authorgroup>
    <pubdate>2001</pubdate>
    <title>Time Series Analysis by State Space Methods</title>
    <publishername>Oxford University Press</publishername>
  </biblioset>
</biblioentry>

<biblioentry>
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Fair</surname>
	<firstname>Ray</firstname>
      </author>
      <author>
	<surname>Taylor</surname>
	<firstname>John</firstname>
      </author>
    </authorgroup>
    <pubdate>1983</pubdate>
    <title>Solution and Maximum Likelihood Estimation of Dynamic Nonlinear Rational Expectation Models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Econometrica</title>
    <volumenum>51</volumenum>
    <pagenums>1169-1185</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Fernandez-Villaverde</surname>
	<firstname>Jesus</firstname>
      </author>
      <author>
	<surname>Rubio-Ramirez</surname>
	<firstname>Juan</firstname>
      </author>
    </authorgroup>
    <pubdate>2004</pubdate>
    <title>Comparing Dynamic Equilibrium Economies to Data: A Bayesian Approach</title>
  </biblioset>
  <biblioset relation="journal">
  <title>Journal of Econometrics</title>
  <volumenum>123</volumenum>
    <pagenums>153-187</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>   
  <biblioset relation="article">
    <author>
      <surname>Ireland</surname>
      <firstname>Peter</firstname>
    </author>
    <pubdate>2004</pubdate>
    <title>A Method for Taking Models to the Data</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Economic Dynamics and Control</title>
    <volumenum>28</volumenum>
    <pagenums>1205-26</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>  
  <biblioset relation="article">
    <author>
      <surname>Judd</surname>
      <firstname>Kenneth</firstname>
    </author>
    <pubdate>1996</pubdate>    
    <title>Approximation, Perturbation, and Projection Methods in Economic Analysis</title>
  </biblioset>
  <biblioset relation="book">
    <authorgroup>
      <author>
	<surname>Amman</surname>
	<firstname>Hans</firstname>
      </author>
      <author>
	<surname>Kendrick</surname>
	<firstname>David</firstname>
      </author>
      <author>
	<surname>Rust</surname>
	<firstname>John</firstname>
      </author>
    </authorgroup>
    <title>Handbook of Computational Economics</title>
    <pubdate>1996</pubdate>
    <publishername>North Holland Press</publishername>
    <pagenums>511-585</pagenums>
  </biblioset>
</biblioentry>

<biblioentry> 
      <author>
	<surname>Juillard</surname>
	<firstname>Michel</firstname>
      </author>
      <pubdate>1996</pubdate>
      <title>Dynare: A program for the resolution and simulation of dynamic models with forward variables through the use of a relaxation algorithm</title>
      <orgname>CEPREMAP</orgname>
      <citetitle>Couverture Orange</citetitle>
      <volumenum>9602</volumenum>
</biblioentry>

<biblioentry>
  <biblioset relation="article">
    <authorgroup>
      <author>
	<surname>Koopman</surname>
	<firstname>S.J.</firstname>
      </author>
      <author>
	<surname>Durbin</surname>
	<firstname>J.</firstname>
      </author>
    </authorgroup>
    <pubdate>2003</pubdate>
    <title>Filtering and Smoothing of State Vector for Diffuse State Space Models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Time Series Analysis</title>
    <volumenum>24</volumenum>
    <pagenums>85-98</pagenums>
  </biblioset>
</biblioentry>

<biblioentry>   
  <biblioset relation="article">
    <author>
      <surname>Laffargue</surname>
      <firstname>Jean-Pierre</firstname>
    </author>
    <title>Résolution d'un modèle macroéconomique avec anticipations rationnelles</title>
    <pubdate>1990</pubdate>
  </biblioset>
  <biblioset relation="journal">
    <title>Annales d'Economie et Statistique</title>
    <volumenum>17</volumenum>
    <pagenums>97-119</pagenums>
  </biblioset>
</biblioentry>
<biblioentry> 
  <authorgroup>
  <author>
    <surname>Lubik</surname>
    <firstname>Thomas</firstname>
  </author>
  <author>
    <surname>Schorfheide</surname>
    <firstname>Frank</firstname>
  </author>
  </authorgroup>
  <pubdate>2003</pubdate>
  <title>Do Central Banks Target Exchange Rates? A Structural Investigation</title>
  <orgname>University of Pennsylvania</orgname>
</biblioentry>
<biblioentry> 
  <authorgroup>
    <author>
      <surname>Rabanal</surname>
      <firstname>Pau</firstname>
    </author>
    <author>
      <surname>Rubio-Ramirez</surname>
      <firstname>Juan</firstname>
    </author>
  </authorgroup>
  <pubdate>2003</pubdate>
  <title>Comparing New Keynesian Models of the Business Cycle: A Bayesian Approach</title>
  <orgname>Atlanta Fed</orgname>
<citetitle>Working Paper</citetitle>
<volumenum>2001-22a, rev 2003</volumenum>
</biblioentry>

<biblioentry> 
  <biblioset relation="article">
    <author>
      <surname>Schorfheide</surname>
      <firstname>Frank</firstname>
    </author>
  <pubdate>2000</pubdate>
  <title>Loss Function-based evaluation of DSGE models</title>
  </biblioset>
  <biblioset relation="journal">
    <title>Journal of Applied Econometrics</title>
    <volumenum>15</volumenum>
    <pagenums>645-70</pagenums>
  </biblioset>
</biblioentry>

<biblioentry> 
  <authorgroup>
    <author>
      <surname>Schmitt-Grohe</surname>
      <firstname>Stephanie</firstname>
    </author>
    <author>
      <surname>Uribe</surname>
      <firstname>Martin</firstname>
    </author>
  </authorgroup>
  <pubdate>2002</pubdate>
  <title>Solving Dynamic General Equilibrium Models Using a Second-Order Approximation to the Policy Function</title>
  <orgname>Rutgers University</orgname>
</biblioentry>

<biblioentry> 
  <authorgroup>
    <author>
      <surname>Smets</surname>
      <firstname>Frank</firstname>
    </author>
    <author>
      <surname>Wouters</surname>
      <firstname>Rafael</firstname>
    </author>
  </authorgroup>
  <pubdate>2002</pubdate>
  <title>An Estimated Stochastic Dynamic General
Equilibrium Model of the Euro Area</title>
  <orgname>European Central Bank</orgname>
      <citetitle>ECB Working Paper</citetitle>
      <volumenum>171</volumenum>
</biblioentry>
</bibliography>
<index>
</index>
</book>

